"use strict";

//////////////////////////////////////////////////////////////////////////////////////
// 4.1 単項式
//////////////////////////////////////////////////////////////////////////////////////

// 最も単項な式は他の式を含まない式である
// このような式を単項式と呼ぶ
// JavaScriptでの単項式としてはリテラル（定数値）、JavaScriptのキーワード、変数参照がある

// リテラルとしてはプログラム中に直接埋め込まれた定数値である

1.23        // 数値リテラル
"hello"     // 文字列リテラル
/pattern/   // 正規表現リテラル

// JavaScriptでの数値リテラルは3.2章で解説済み
// 文字列リテラルについては3.3章で解説済み
// 正規表現リテラルについては3.3.5章で概要を解説済み
// 詳細については11.3章で解説する

// JavaScriptの予約語には単項式として使えるものがある

true        // 論理値のtrueの値に評価される
false       // 論理値のfalseの値に評価される
null        // null値に評価される
this        // 「現在の」オブジェクトに評価される

// true, false, nullについては3.4章と3.5章で解説済み
// 他のキーワードと異なり、thisは定数ではない
// プログラム中のさまざまな場所で、さまざまな値に評価される
// thisキーワードはオブジェクト指向プログラミングでよく使われるキーワードである
// メソッド本体でthisを使えば。メソッドが呼び出されたオブジェクトを参照できる
// thisについて詳しくは4.5章、8章(8.2.2章)、9章で解説する

// 最後に紹介する単項式は変数や定数、グローバルオブジェクトのプロパティ参照である

i           // 変数iの値に評価される
sum         // 変数sumの値に評価される
undefined   // グローバルオブジェクトの「undefined」プロパティの値に評価される

// プログラム中に識別子が現れた場合、JavaScriptは変数または定数、グローバルオブジェクトのプロパティと認識し、値を検索する
// 該当する名前の変数が存在しない場合、存在しない変数を評価するとReferenceErrorがスローされる

//////////////////////////////////////////////////////////////////////////////////////
// 4.2 オブジェクトと配列の初期化子
//////////////////////////////////////////////////////////////////////////////////////

// オブジェクトと配列の初期化子とは、新たに生成されるオブジェクトや配列の値となる式のことである
// このような初期化子は「オブジェクトリテラル」や「配列リテラル」と呼ばれることがある
// しかし、本当のリテラルとは異なり単項式ではない
// なぜならプロパティの値や要素の値を指定するために複数の式が含まれるからである
// 配列の初期化子のほうがいくぶん単純であるためこちらから解説する

// 配列初期化子とは、カンマで区切った式のリストを角括弧で囲んだものである
// 配列の初期化子の値は、新たに生成された配列になる
// この配列の要素は、カンマで区切られた式の値に初期化される

[]          // 空の配列 角括弧中に式がない場合、要素がないことを意味する
[1+2, 3+4]  // 要素を2つ持つ配列 1つ目の要素が3 2つ目の要素が7

// 配列初期化子中の要素として、配列初期化子を記述しても構わない
// この場合、入れ子になった配列が生成される

let matrix = [[1, 2, 3], [4, 5, 6], [7, 8, 9]];

// 配列初期化子が評価されるたびに、配列初期化子中の要素の式も評価される
// つまり、配列初期化子の値は、評価されるたびに異なる可能性がある

// 未定義の要素を配列リテラル中に含めたい場合、カンマの値を省略する
// 例えば、次の例は要素を5つもつが、3つの要素は未定義の要素になる

let sparseArray = [1,,,,5];

// 配列初期化子の最後の式の後にカンマを1つ記述しても構わない
// この場合、未定義要素は作成されない
// ただし、最後の式より後のインデックスに対して配列アクセスを行うと、未定義値と評価される

// オブジェクト初期化子は、配列初期化子と同じような書式だが、角括弧の代わりに中括弧を使い、
// 各式の前にはプロパティ名とコロンを記述する

let p = {x: 2.3, y: -1.2};     // 2つプロパティを持つオブジェクト
let q = {};                     // プロパティを持たない空のオブジェクト
q.x = 2.3; q.y = -1.2;          // これでqはpと同じプロパティを持つ

// ES6ではオブジェクトリテラルにもっと高機能な構文が使える
// 詳しくは6.10章で解説
// オブジェクトリテラルは次のように入れ子にできる

let rectangle = {
    upperLeft: {x: 2, y: 2},
    lowerRight: {x: 4, y: 5}
};

// オブジェクト初期化子（オブジェクトリテラル）と配列初期化子（配列リテラル）については6章、7章で解説

//////////////////////////////////////////////////////////////////////////////////////
// 4.3 関数定義式
//////////////////////////////////////////////////////////////////////////////////////

// 関数定義式は、JavaScriptの関数を定義する
// この式の値は新たに定義される関数になる
// オブジェクト初期化子が「オブジェクトリテラル」と呼ばれるのと同じように、関数定義式も「関数リテラル」と呼ぶ
// 関数定義式は、一般的にはfunctionキーワードに続いて、カンマで区切って0個以上の識別子（パラメータ名）を丸括弧中に記述し、
// 中括弧中にJavaScriptコードブロック（関数本体）を記述する

// この関数は引数として渡された値の自乗を返す
let square = function(x) {
    return x * x;
};

// 関数定義式には無名を記述できる
// 関数は、関数定義式のかわりに、関数分を使って定義することもできる
// また、ES6以降では「アロー関数」というコンパクトな構文を使うこともできる
// 関数定義の詳細については8章で解説

//////////////////////////////////////////////////////////////////////////////////////
// 4.4 プロパティアクセス式
//////////////////////////////////////////////////////////////////////////////////////

// プロパティアクセス式は、オブジェクトプロパティの値、または配列の要素の値に評価される
// JavaScriptにはプロパティ用に2つの構文が用意されている

式.識別子
式[式]

// 前者の方法では、式の後にピリオドと識別子を記述している
// 式がオブジェクトを指定し、識別子でアクセスしたいプロパティの名前を指定する
// 後者の方法では、最初の式（オブジェクトまたは配列になる）の後に、角括弧で囲んだ式が続く
// この2番目の式で、アクセスしたいプロパティ名や、アクセスしたい配列要素のインデックスを指定する

let o = {x: 2, y: {z: 3}};      // 例となるオブジェクト
let a = [o, 4, [5, 6]];         // オブジェクトを含む配列の例
o.x                             // 1: 式oのプロパティxの値
o.y.z                           // 3: 式0.yのプロパティzの値
o["x"]                          // 1: オブジェクトoのプロパティxの値
a[1]                            // 4: 式aのインデックス1の要素の値
a[2]["1"]                       // 6: 式a[2]のインデックス1の要素の値
a[0].x                          // 1: 式a[0]のプロパティxの値

// どちらのプロパティアクセス式を使っても、.や[の前の式がまず評価される
// 評価した値がnullやundefinedになった場合、TypeErrorがスローされる
// この2つの値はJavaScriptでプロパティを持てないからである
// オブジェクト式の後に、ドットと識別子が続く場合、識別子で指定されたプロパティ名が検索され、この値がプロパティアクセス式全体の値となる
// オブジェクト式の後に角括弧が続く場合、2番目の式を評価し文字列に変換する
// この文字列と同じ名前のプロパティの値が、プロパティアクセス式全体の値になる
// どちらの場合も、指定された名前のプロパティが存在しない場合は、プロパティアクセス式の値はundefinedになる

// 2つの方法を比べると、.識別子構文の方が簡単である
// ただし、この形式が使えるのは、アクセスしたいプロパティの名前が識別子として使え、またプロパティを書くときにその名前を知っているときだけである
// 例えば、プロパティ名が予約語であったり、空白や句読点文字を含んでいたりする場合や、
// （配列などで）数値の場合は、角括弧を使って記述しなければならない
// また、プロパティ名が静的に決まるのではなく、計算結果できまるような場合にも角括弧が使われる（6.3.1章参照）
// オブジェクトとプロパティについては6章で解説
// 配列と要素については7章で解説

//////////////////////////////////////////////////////////////////////////////////////
// 4.4.1 条件付きプロパティアクセス
//////////////////////////////////////////////////////////////////////////////////////

// ES2020では次に示すようなプロパティアクセス式が新たに2種類追加された

式?.識別子
式?.[式]

// JavaScriptではnullとundefinedだけがプロパティを持たない値である
// .や[]という通常のプロパティアクセス式を使った場合、左側の式がnullやundefinedに評価された場合、TypeErrorがスローされてしまう
// ?.や?.[]構文を使うとこのようなエラーを防ぐことができる

// a?.bを例にとって説明する
// もしもaがnullまたはundefinedの場合、この式はundefinedと評価され、プロパティbをアクセスしない
// もしもaが何らかの値を保つ場合、a?.bはa.bを評価したのと同じ値に評価される
// （もしも、aがbという名前のプロパティを持たない場合、この値はundefinedになる）

// この形式のプロパティアクセス式は「オプショナルチェイニング」と呼ばれることもある
// 次のように長く連結（チェイン）されたプロパティアクセス式で使えるものだからである

let a = { b: null };
a.b?.c.d                // undefined

// aはオブジェクトなので、a.bは正当なプロパティアクセス式である
// しかし、a.bの値はnullなので、a.b.cはTypeErrorをスローする
// .の代わりに?.を使うことでTypeErrorがスローされないようになり、a.b?.cはundefinedと評価される
// また、(a.b?.c).dという式は、undefined値のプロパティにアクセスすることになるので、TypeErrorがスローされる
// ただし、丸括弧をつけないでa.b?.c.dと記述した場合は、単純にundefinedと評価され、TypeErrorはスローされない
// これが「オプショナルチェイニング」の非常に重要な機能である
// ?.の左辺にある式がnullまたはundefinedの場合、式全体が即座にundefinedと評価される
// 以降のプロパティアクセスは行われない

// もちろんa.bがオブジェクトでこのオブジェクトがcという名前のプロパティを持っていない場合、a.b?.c.dはTypeErrorをスローする
// この場合は、次のように条件付きプロパティアクセスをもう1つ追加する

let a = { b: {} };
a.b?.c?.d           // undefined

// []の代わりに?.[]と記述しても条件付きプロパティアクセスが行われる
// a?.[b][c]という式では、aの値がnullまたはundefinedの場合、式全体が即座にundefinedと評価される
// この場合、bやcという式は評価されない
// どちらかの式が副作用を持つような式の場合も、その副作用は実行されない

let a;          // この変数を初期化し忘れている
let index = 0;
try {
    a[index++]; // TypeErrorをスローする
} catch(e) {
    index       // 1: TypeErrorがスローされる前にインクリメントが実行される
}
a?.[index++]    // undefined: aがundefinedなので
index           // 1: ?.[]は即座に値を評価するのでインクリメントは行われない
a[index++]      // !TypeError: 未定義値にインデックスは指定できない

// 条件付きプロパティアクセス(?.と?.[])はJavaScriptの最新機能の1つである
// 2020年初頭段階では、この構文は主要ブラウザの最新バージョンまたはβバージョンでサポートされている

//////////////////////////////////////////////////////////////////////////////////////
// 4.5 呼び出し式
//////////////////////////////////////////////////////////////////////////////////////

// 呼び出し式は、JavaScriptにおいて関数やメソッドを呼び出す（実行する）ための構文である
// まず、呼び出される関数を指定するための関数式を記述する
// この関数式の後に、開き丸括弧を記述し、カンマで区切って0個以上の引数式を記述し、最後に閉じ丸括弧を記述する

f(0)                // fは関数式、0は引数式
Math.max(x, y, z)   // Math.maxは関数、 x、ｙ，ｚは引数
a.sort()            // a.sortは関数、引数はない

// 引き出し式が評価されるときは、まず関数式が評価され、続いて引数式が評価され、引数の値のリストが生成される
// 関数式の値が関数にならない場合、TypeErrorがスローされる
// 続いて、引数値が関数定義時に指定されたパラメータに代入され、関数本体が実行される
// 関数は、return文を使うことで値を返すことができる
// この値が呼び出し式の値となる
// return文がない場合には、呼び出し式の値はundefinedになる
// 関数呼び出しの詳細については8章で解説する
// 8章では引数式の数が関数定義時のパラメータの数と一致しなかった場合の挙動についても解説する

// 呼び出し式は一対の丸括弧と、引き丸括弧の前の式から構成される
// この式がプロパティアクセス式の場合には、メソッド呼び出しになる
// メソッド呼び出しの場合は、プロパティアクセスの対象となるオブジェクトや配列がthisキーワードの値となる
// そして、このthisの値を関数本体で利用できるようになる
// このような構造により、オブジェクト指向プログラミング風に関数（オブジェクト指向には「メソッド」）から、
// オブジェクトを操作できるようになる
// 詳しくは9章で解説する

//////////////////////////////////////////////////////////////////////////////////////
// 4.5.1 条件付き呼び出し
//////////////////////////////////////////////////////////////////////////////////////

// ES2020では()の代わりに?.()を使って関数を呼び出すこともできる
// 通常の関数呼び出しでは、丸括弧の左側がnullまたはundefined、関数ではない値であった場合、TypeErrorがスローされる
// ?.()呼び出し構文を使った場合、?.の左側の式がnullやundefinedに評価された場合、関数呼び出し式全体がundefinedと評価される
// 例外はスローされない

// 配列オブジェクトのsort()メソッドには、オプションの引数として関数を渡すことができる
// この関数で、配列要素をソートする順序を定義する
// ES2020より前の使用では、sort()のように関数オプションの引数として受け取るメソッドを記述したい場合は、次の例のように、
// if文を使って関数引数が定義されているかどうかを確認した後に、if文の本体で関数を呼び出すようにしていた

function square(x, log) {       // 第2引数はオプションの関数

    if(log) {                   // オプションの関数が渡されていれば
        log(x);                 // その関数を呼び出す
    }
    return x * x;               // 引数の自乗を返す

}

// しかし、ES2020の条件付き呼び出し構文を使えば、実際に呼びさせる値がある場合にのみ呼び出しが行われるので、
// ?.()を使って単純に関数を呼び出すだけで住む

function square(x, log) {       // 第2引数はオプションの関数

    log?.(x);                   // 関数が渡されていればその関数を呼び出す
    return x * x;               // 引数の自乗を返す

}

// なお、?.()が確認するのは左側の式がnullまたはundefinedかどうかだけである
// 関数かどうかは確認しない
// 先ほどの例のsquare()関数も引数として数値を2つ渡せば例外がスローされる

// ?.()を使った関数呼び出しは条件付きプロパティアクセス式(4.4.1章)と同じような動きをする
// ?.の左側がnullまたはundefinedの場合、丸括弧の中の引数式はすべて消化されない

let f = null, x = 0;
 try {
    f(x++);         // fはnullなのでTypeErrorをスローする
 } catch(e) {
    x               // 1: 例外がスローされる前にxがインクリメントされる
 }
 f?.(x++)           // undefined: fがnullの場合、例外はスローされない
 x                  // 1: 引数は評価されないので、インクリメントは行われない

// 条件付き呼び出し式は、関数と同じようにメソッドを使える
// ただしメソッド呼び出しについてはプロパティアクセスを伴うため、次の式の違いを理解すること

o.m()               // 通常のプロパティアクセス、通常の呼び出し
o?.m()              // 条件付きプロパティアクセス、通常の呼び出し
o.m?.()             // 通常のプロパティアクセス、条件付き呼び出し

// 最初の式では、oはプロパティmを持つオブジェクトでなければならない
// また、プロパティmは関数でなければならない
// 2つ目の式は、oがnullやundefinedの場合、この式全体はundefinedに評価される
// しかし、oが何らかの値を持つ場合、プロパティmの値は関数でなければならない
// そして、3つ目の式ではoはnullやundefinedであってはならない
// oがプロパティmを持たなかったり、プロパティmの値がnullであったりした場合、この式全体はundefinedに評価される

// ?.()を使った条件付き呼び出しはJavaScriptの最新機能の1つである
// 2020年初頭の段階では、この構文は多くの主要なブラウザの最新バージョンやβバージョンで実装されている

//////////////////////////////////////////////////////////////////////////////////////
// 4.6 オブジェクトの生成
//////////////////////////////////////////////////////////////////////////////////////

// オブジェクト生成式は新たにオブジェクトを生成し、コンストラクタと呼ばれる関数を呼び出して、
// オブジェクトのプロパティを初期化する
// オブジェクト生成式は呼び出し式と非常に似ている
// ただし式の前にnewキーワードを記述する点が異なる

new Object()
new PointerEvent(2, 3)

// オブジェクト生成式中のコンストラクタ関数に引数を渡さない場合は、丸括弧を省略しても構わない

new Object
new Date

// オブジェクト生成式の値は、新たに生成されたオブジェクトになる
// コンストラクタについては9章で詳しく解説する

//////////////////////////////////////////////////////////////////////////////////////
// 4.7 演算子の概要
//////////////////////////////////////////////////////////////////////////////////////

// JavaScriptにおいて、演算子は算術式や比較式、論理式、代入式なので使われる
// 演算子の一覧表を表4-1に示す

// ほとんどの演算子は+や=などの記号で表せる 
// しかし、deleteやinstanceofのようにキーワードで表される演算子もある
// キーワードで表される演算子も、記号で表せる演算子と同じく普通の演算子である
// 単に読みやすい表記になっているだけである

// 表4-1は演算子の優先順位順にまとめている
// 初めの方に記述している演算子のほうが、後ろに記述している演算子より優先順位が高い
// 表中の横線で、演算子の優先順位が変わる
// A(associativity)は式の結合性を記す
// Lは左から右の順(left-to-right)で評価する、Rは右から左の順(right-to-left)で評価するという意味
// Nという列はオペランドの数を表す
// 型という名前の列には、想定するオペランドの方と、→の後に演算子の結果の型を列挙している
// 以下の項では、優先順位や結合性、オペランドの型という概念について説明する
// その後に各演算子について説明する

// 表4-1 JavaScript演算子.png 参照

//////////////////////////////////////////////////////////////////////////////////////
// 4.7.1 オペランドの数
//////////////////////////////////////////////////////////////////////////////////////

// 演算子はオペランドの数で3種類に大別できる
// 1つは二項演算子である
// 蒸散演算子（*）などがそうで、2つの式を組み合わせて、より複雑な1つの式を作る
// 操作対象となる終えpランド（被演算子）が2つ必要なので、二項演算子と呼ばれる
// 2つ目は単項演算子である
// 1つの式をもっと複雑な別の式に変換する
// 例えば-xという式の-がそうで、この演算子はオペランドxに対して符号反転を実行する
// 最後の1つは三項演算子である
// JavaScriptで使用できる演算子は、条件演算子（?:）だけである
// ?:は3つの式を組み合わせて1つの式を作れる演算子である

//////////////////////////////////////////////////////////////////////////////////////
// 4.7.2 オペランドと演算結果の型
//////////////////////////////////////////////////////////////////////////////////////

// 任意の型の値を処理できる演算子もあるが、多くの演算子はオペランドとして特定の型を必要としている
// また、同じように多くの演算子はある特定の型の値を返す
// 表4-1の「型」列にオペランドの型と、演算子の演算結果の型を示す
// 矢印の前がオペランドの方で、矢印の後が演算結果の型である

// JavaScriptの演算子は必要に応じてオペランドの型を変換する（3.9章）
// 乗算演算子（*）はオペランドとして数値を必要とする
// しかし、"3" * "5"という式は全く問題ない
// JavaScriptがオペランドを数値に変換するためである
// この式の値は15になり、文字列の"15"ではない
// また、JavaScriptでは値は「trueに変換されるもの」または「falseに変換されるもの」のどちらかになる
// したがって、オペランドとして論理値が必要な演算子でも任意の型のオペランドに対して問題なく動作する

// オペランドの型によって動きが変わる演算子もいくつかある
// 例えば、+演算子の場合、オペランドの型が数値なら加算を実行するが、オペランドの型が文字列であれば連結処理を行う
// 同じように、<などの比較演算子はオペランドの型によって、数値の大小で比較したり、アルファベット順で比較したりする
// 個々の演算子についての説明の中で必要とする型やどのような型変換が行われるかについても解説する

// 表4-1を見ると、代入演算子などいくつかの演算子で、オペランドの型として「左辺値」を必要とするものがある
// 左辺値とは、昔から使われている用語で「代入演算子の左辺に記述して問題ない式」という意味である
// JavaScriptの場合、変数やオブジェクトのプロパティ、配列の要素が左辺値になる

//////////////////////////////////////////////////////////////////////////////////////
// 4.7.3 演算子の副作用
//////////////////////////////////////////////////////////////////////////////////////

// 2 * 3のような単純な式を評価したとしても、プログラムの状態は何も変化しない
// また、今後行う計算にも、この式の評価は何も影響しない
// しかし、式の中には副作用を持つものがあり、その後の評価結果を変えてしまう場合がある
// 代入演算子が最もわかりやすい例で、変数やプロパティに値を代入すれば、今後その値やプロパティを使う式の値が変化する
// 同じように、インクリメント演算子（++）やデクリメント演算子（--）も暗黙的に代入を行うので副作用が生じる
// delete演算子も副作用があり、プロパティを削除することは、プロパティにundefinedを代入するのとほぼ同じ意味になるからである

// JavaScriptではこのほかの演算子には副作用はない
// ただし、関数呼び出し式やオブジェクト生成式は、関数中やコンストラクタ本体で前述したような演算子が使われた場合に副作用を持つことになる

//////////////////////////////////////////////////////////////////////////////////////
// 4.7.4 演算子の優先順位
//////////////////////////////////////////////////////////////////////////////////////

// 表4-1に列挙した演算子は、優先順位の高いものから順に並べている
// 同じ優先順位のものは、横線を引いてグループ分けしている
// 演算子が複数ある場合に、どの演算子から演算を行うかが、この優先順位で制御される
// つまり、表の上の方に挙げている優先順位の高い演算子から処理が行われる

w = x + y * z;

// 乗算演算子*のほうが加算演算子+より優先順位が高いので、まず乗算が行われ、次に加算が行われる
// 代入演算子=は優先順位が最も低いので、右辺の処理がすべて終了した後に実行される

// 優先順位を変更したい場合は、丸括弧()を使用する
// 上記の例で加算を実行してから乗算を実行したい場合は次のようにする

w = (x + y) * z;

// プロパティアクセス式と呼び出し式は、表4-1のすべての演算子より優先順位が高くなる

// myはfunctionsという名前のプロパティを持つ
// このプロパティの値は、関数の配列
// 数値x番目の関数を呼び出して、引数としてyを渡す
// その後、戻り値ｗの型を調べる

typeof my.functions[x](y)

// typeofは優先順位が最高の演算子の1つだが、プロパティアクセスや配列インデックス、関数呼び出しがまず実行され、その結果に対して、typeof演算が行われる
// これらの処理はすべて、演算子よりも優先度が高いものである

// 演算子の優先順位がよく分からない場合は、丸括弧を使用して明示的に評価順序を指定することをお勧めする
// とりあえず、まず乗算と除算が行われ、次に加算と減算が行われ、最後に代入処理が行われることを覚える

// JavaScriptに新しい演算子が追加されたとき、この優先順位の規則に従うものばかりではない
// ??演算子(4.13.2章)は表の中では||や&&演算子よりも優先順位が低いことになっている
// しかし、実際には??演算子と||、&&演算子の優先順位は定義されていない
// ES2020では、??演算子と||、&&演算子を組み合わせる場合は、丸括弧を明示的に使わなければならない
// 同じように新たに追加された**演算子は、単項マイナス演算子と優先順位が明確に定義されていない
// べき乗と負号の組み合わせは丸括弧を使わなければならない

//////////////////////////////////////////////////////////////////////////////////////
// 4.7.5 演算子の結合性
//////////////////////////////////////////////////////////////////////////////////////

// 表4-1でA(associativity)の列は演算子の結合性を示している
// A列のL(left-to-right)は左から右に演算子を結合するという意味である
// 同様にR(right-to-left)は右から左へ演算子を結合するという意味である
// このようなルールは優先順位が同じ演算子の実行順序を決めるときに必要になる
// Lが指定されていれば、左から右へ順に処理される

w = x - y - z;

// 減算演算子は左から右に処理されるため、次のように丸括弧を記述したのと同じである

w = ((x - y) - z);

// 一方次の例を見る

y = a ** b ** c;
x = ~-y;
w = x = y = z;
q = a?b:c?d:e?f:g;

// べき乗演算子や単項演算子、代入演算子、条件演算子は右から左へ処理されるため、
// これらの式は次のように記述したのと同じである

y = (a ** (b ** c));
x = ~(-y);
w = (x = (y = z));
q = a?b:(c?d:(e?f:g));

//////////////////////////////////////////////////////////////////////////////////////
// 4.7.6 評価順序
//////////////////////////////////////////////////////////////////////////////////////

// 演算子の優先順位と結合性により、複雑な式の中の演算子の処理順序が決められる
// しかし、優先順位と結合性は、個々の式が評価される順序までは指定しない
// JavaScriptでは常に式の評価は左から右に行われる
// 例えば、w = x + y * zという式の場合、まずwが評価され、その後、x、y、zの順序で評価が行われる
// そして、yとzの値が乗算され、xの値と加算され、wという式で指定された変数やプロパティに代入が行われる
// 式に対して、丸括弧を追加すれば、乗算や加算、代入の順序を変更できるが、評価の順（左から右）は変更はできない

// 評価の順序が問題となるのは、評価される式の中の副作用を持ち、この副作用がほかの式に影響を与える場合だけである
// もしも先ほどの例で、z式で使う変数がx式の中でインクリメントされる場合、xがzよりも前に評価されるという評価の順序が重要になる

//////////////////////////////////////////////////////////////////////////////////////
// 4.8 算術演算式
//////////////////////////////////////////////////////////////////////////////////////

// この節では、オペランドに対して算術演算など数値処理を行う演算子について解説する
// 簡単なべき乗演算子、乗算演算子、除算演算子、減算演算子からまず紹介する
// 加算演算子は、文字列の連結処理を行ったり、通常とは異なる型変換規則を使ったりするので、
// 項を分けて解説する、同じように単項演算子や、ビット演算子についても項を設けて解説する

// 算術演算子の多くは、BigInt（3.2.5章）のオペランドに対しても、通常の数値に対しても使うことができる
// ただし、BigIntと通常の数値を混ぜることはできない

// 基本的な算術演算子は、べき乗演算子（**）、乗算演算子（*）、除算演算子（/）、剰余演算子（%）、加算演算子（+）、減算演算子（-）である
// すでに述べたように、+演算子については、項を分けて解説する
// 残りの5つの演算子についてはオペランドを評価し、必要に応じて値を数値に変換し、べき乗や積、商、余り差を計算するのみ
// オペランドが数値に変換できない場合には、NaN値に変換する
// オペランドの一方がNaN（に変換される値）の場合、演算結果もNaNになる

// **演算子は（+や-よりも優先度の高い）*、/、%よりも優先度の高い演算子である
// 他の演算子とは異なり、**は右から左へ処理される
// つまり、2 ** 2 ** 3 は、2 ** 8 と同じになる
// 4 ** 3 ではない
// 一方で、-3 ** 2 という式には曖昧さが残る
// 単項マイナスとべき乗演算子の優先度によって、この式は（-3） ** 2 または -(3 ** 2)という意味になる 
// そして、プログラミング言語によって、優先度が異なる
// JavaScriptでは、どのプログラミング言語の優先度を採用するかを決める代わりに、丸括弧を使わない場合は構文エラーになるようにした
// このような式を記述する場合は必ず丸括弧を使用すること
// **は、ES2016からJavaScriptに追加された演算子である
// ただしES2016より前のバージョンでも**演算子とまったく同じ処理を行う、Math.pow()関数が利用できた

// /演算子は最初のオペランドを、2番目のオペランドで割る
// 整数と浮動小数点を区別するようなプログラミング言語に慣れ親しんでいる方だと、整数を整数で割ると、商も整数になると思うでしょう
// しかしJavaScriptの場合、すべての数値は浮動小数点なので、除算の結果も浮動小数点になる
// つまり、5 / 2の結果は2ではなく、2.5になる
// 0で除算した場合、正または負の無限大になる
// 0 / 0はNaNになる
// いずれの場合もエラーにならない

// %演算子は、最初のオペランドを2番目のオペランドで割った余りを計算する
// つまり最初のオペランドを2番目のオペランドで、商が整数になるような割り算をしたときの余りを返す
// 演算結果の符号は、最初のオペランドの符号と同じになる
// 例えば、5 % 2は1になり、-5 % 2は-1になる

// なお、余剰演算子は整数値に対して使われるのが一般的だが、浮動小数点に対しても問題なく動作する
// 例えば、6.5 % 2.1は0.2になる

//////////////////////////////////////////////////////////////////////////////////////
// 4.8.1 +演算子
//////////////////////////////////////////////////////////////////////////////////////

// 二項演算子の+演算子は、数値オペランドがあれば加算を行い、文字列オペランドの場合は結合を行います

1 + 2                       // 3
"hello" + " " + "there"     // "hello there"
"1" + "2"                   // "12"

// 両方のオペランドの値が数値の場合、または両方のオペランドの値が文字列の場合は、+演算子がどのような処理をするかは明らかである
// しかし、このほかの場合には、型変換が必要となる
// +演算子の型変換規則では、文字列の結合が優先的に行われる
// オペランドの一方が文字列、または文字列に変換できるオブジェクトの場合、もう一方のオペランドは文字列に変換され、連結処理が行われる

// 正確に言えば、+演算子は次のように振る舞う

// オペランドの値のどちらかがオブジェクトの場合、3.9.3章で解説したオブジェクトから基礎型値への変換アルゴリズムを使って、オブジェクトを基本型に変換する
// Dateオブジェクトは、toString()メソッドを使って変換を行う
// そのほかのオブジェクトは、valueOf()メソッドが基本型値を返すのであればvalueOf()メソッドを使って型変換を行う
// しかし、多くのオブジェクトは意味のあるvalueOf()メソッドを持たないので、その場合はtoString()を使って型変換を行う

// オブジェクトから基本型へ型変換の後、オペランドの一方が文字列の場合、もう一方のオペランドも文字列に変換し連結処理を行う

// それ以外の場合は、両方のオペランドを数値（またはNaN）に変換し、加算処理が行われる

1 + 2               // 3: 加算
"1" + "2"           // "12": 連結
"1" + 2             // "12": 数値から文字列へ変換の後、連結
"1" + {}            // "1[object Object]": オブジェクトから文字列の変換の後、連結
true + true         // 2: 論理値から数値へ変換の後、加算
2 + null            // 2: nullを0に変換した後、加算
2 + undefined       // NaN: undefinedをNaNに変換した後、加算

// 文字列と数値に対して、+演算子を使った場合、結合法則が成り立たない場合がある
// つまり、演算子の実行順序によって演算結果が変わってしまうということである

1 + 2 + " blind mice"       // "3 blind mice"
1 + (2 + " blind mice")     // "12 blind mice"

// 最初の行は丸括弧がなく、+演算子は左から右に処理されるので、2つの数値がまず加算される
// そして、その加算結果が文字列に連結される
// 2番目の行では、丸括弧によって演算順序が変更されている
// 数値の2が連結されて新しい文字列が生成される
// 次に、数値1も文字列として連結され、最終的な文字列が得られる

//////////////////////////////////////////////////////////////////////////////////////
// 4.8.2 単項算術演算子
//////////////////////////////////////////////////////////////////////////////////////

// 単項演算子は、1つのオペランドの値に対して処理を行い、新たな値を生成する
// JavaScriptでは単項演算子はすべて優先順位が高く、すべて右結合成を持つ
// この項で解説する単項算術演算子（+、-、++、--）はすべて、必要に応じてオペランドを数値に変換する
// なお、+と-は単項演算子としても二項演算子としても使われることに注意すること

// 単項プラス（+）
// 単項プラス演算子は、オペランドを数値（またはNaN）に変換し、変換した値を返す
// オペランドがすでに数値の場合には、この演算子は何もしない
// BigInt値に対して単項プラス演算子を使うことはできない
// BigInt値は通常の数値に変換できないためである

// 単項マイナス（-）
// -を単項演算子として使うと、必要に応じて、オペランドを数値に変換し、変換結果の符号を反転させる

// インクリメント（++）
// ++演算子は、オペランドをインクリメントする（1を加える）
// オペランドは変数や、配列の要素、オブジェクトのプロパティなど、左辺値でなければならない
// オペランドを数値に変換し、この数値に1を加算し、加算した結果を変数や要素、プロパティに代入し直す
// ++演算子の戻り値は、オペランドと位置関係で変わる
// オペランドの前で使った場合（前置インクリメント演算子）、オペランドをインクリメントし、インクリメント後の値が評価結果になる
// オペランドの後で使った場合（後置インクリメント演算子）、オペランドをインクリメントし、インクリメント前の値が評価結果になる

let i = 1, j = ++i;     // iもjも2
let n = 1, m = n++;     // nは2だが、mは1

// x++という式は、x=x+1と常に同じという訳ではない
// ++演算子は、文字列の結合処理を行わない
// ++演算子はオペランドを常に数値に変換し、インクリメントする
// xが文字列の1の場合、++xは数値の2になる
// これに対して、x+1は文字列の"11"になる

// また、JavaScriptが自動的にセミコロンを挿入するために、オペランドと後置インクリメント演算子の間には改行を入れてはならない
// もしも、改行を入れてしまうと、JavaScriptはオペランドだけで1つの完成した文字と判断し、後置演算子の前にセミコロンを挿入してしまう

// このインクリメント演算子は、前置形式のものも後置形式のものも、forループ（5.4.5章）のカウンタをインクリメントするときによく使われる

// デクリメント（--）
// --演算子は、オペランドとして左辺値を必要とする
// オペランドを数値に変換し、この数値から1を減算し、減算した結果をオペランドに代入し直す
// ++演算子と同じように、--演算子の値も、オペランドに対する位置によって変わる
// --をオペランドの前に置くと、そのオペランドの値から1を引き、1を引いた値が返される
// オペランドの後ろに--を置いた場合は、そのオペランドの値から1を引く点は同じだが、元のままの値（1を引く前の値）が返される
// オペランドの後に記述する場合は、オペランドと--演算子の間に改行を入れないようにすること

//////////////////////////////////////////////////////////////////////////////////////
// 4.8.3 ビット演算子
//////////////////////////////////////////////////////////////////////////////////////

// ビット演算子は、2新表記の数値のビットを操作するための低レベル演算子である
// ビット演算子は一般的な算術演算は行わない
// しかし、ビット演算子は数値オペランドに対して処理を行い、演算結果も数値になるため、ここではビット演算子も算術演算子に分類される
// 最初の4種類の演算子は、オペランドの各ビットを論理値（1をtrue、0をfalse）と見なし、ビット単位で論理演算を実行する
// 残りの3種類は、左や右へビットを移動する演算子である
// ビット演算子は、JavaScriptプログラミングではあまり使われることはない
// 負数の2の補数表現など、整数の2進表記にあまり馴染みのない方はこの項を飛ばしても問題ない

// ビット演算子はオペランドとして整数値が必要である
// また、この整数値は64ビットの浮動小数点表現形式ではなく、32ビット整数表現形式で表されているのもとして処理を行う
// これらの演算子は、必要であればオペランドを数値に変換し、オペランドの小数点部分を削除したり、
// 33ビット目以上のビットを捨てたりすることで、32ビットの整数表現で表せるようにする
// シフト演算子の右側オペランドには、0から31までの数値が必要である
// まず、オペランドを符号なしの32ビットの整数に変換した後、2進数表記の6ビット名城のビットを無視することで、0から31までに収まるようにする
// 意外に思うかもしれないが、NaN、Infinity、-Infinityをビット演算子のオペランドとして使うと0に変換される

// この項で紹介するビット演算子は>>>演算子を除いてすべて、通常の数値オペランドにもBigInt(3.2.5章)にも使うことが可能

// ビット積演算子（&）
// ビット積演算子（&）は、整数引数の各ビット単位で論理積を計算する
// 両方のオペランドではそれぞれ対応するビットが1のとき、結果のビットが1になる
// 例えば、0x1234 & 0x00FFの評価結果は0x0034となる

// ビット和演算子（|）
// ビット和演算子（|）は、整数引数の各ビット単位で論理和を計算する
// どちらか一方または両方のオペランドでそれぞれ対応するビットが1のときに結果のビットが1になる
// 例えば、0x1234 | 0x00FFの評価結果は0x12FFとなる

// ビット排他的論理和演算子（^）
// ビット排他的論理和演算子（^）は、整数引数の各ビット単位で排他的論理和を計算する
// 2つのオペランドのどちらか一方で対応するビットが1のときに（両方が1の場合を除く）結果のビットが1になる
// 排他的論理和はどちらか一方がtrueであるが、両方はtrueではないという意味である
// 例えば、0xFF00 ^ 0xF0F0 の評価結果は0x0FF0になる

// ビット否定演算子（~）
// ビット否定演算子（~）は単項演算子で。オペランドは整数引数が1つだけである
// ビット否定演算子は、オペランドのすべてのビットを反転させる
// JavaScriptでは、符号を変えて1を引いた値になる
// 例えば、~0x0f（15）の評価結果は0xfffffff0（−16）になる

// 左シフト演算子（<<）
// 左シフト演算子（<<）は、前のオペランドのすべてのビットを後ろのオペランドに指定された数だけ左側に移動させる
// この数は0から31までの範囲の整数になる
// 例えば、a << 1 は、aの右端のビットを右から2番目のビットに、aの右から2番目にあったビットを3番目に、という具合に順にシフトしていく
// 新しい右端のビットにはゼロが入り、元の32番目のビットは捨てられる
// このように1つずつビット位置をシフトする操作は、元の値に2を掛ける演算と同じになる
// ビット位置を2つシフトすると、4倍したことになる
// 例えば、7 << 2の評価結果は28になる

// 符号付き右シフト演算子（>>）（左端に符号ビットをコピー）
// 符号付き右シフト演算子（>>）は、前のオペランドのすべてのビットを後ろのオペランドに指定された数だけ右側に移動させる
// この数は0から31までの範囲の整数になる
// 右側からはみ出たビットは捨てられる
// 左端には、元のオペランドの符号ビットと同じ値が入る
// これは、結果の符号を元と同じ符号にするためである
// 元のオペランドが正なら、左端のビットにゼロが入る
// 元のオペランドが負なら、左端ビットに1が入る
// ビット位置を右に1つだけシフトすると、2で割って余りを捨てるのと同じ結果になる
// ビット位置を右に2つシフトすると、4で割って余りを捨てるのと同じ結果になる
// 例えば、7 >> 1と-7 >> 1の評価結果は、それぞれ3と−4になる

// 符号なし右シフト演算子（>>>）（左端ビットは常に0）
// 符号なし右シフト演算子（>>>）は、左端に入る値が前のオペランドの符号にかかわらず常に0であること以外は、>>演算子と同じである
// 符号付きの32ビット整数を符号なし整数として扱いたいときにこの演算子を使う
// 例えば、-1 >> 4と-1 >>> 4の評価結果は、それぞれ-1と0x0fffffffになる
// ビット演算子の中で、この>>>演算子だけは、BigInt値に使うことができない
// この>>>演算子は最上位ビットを1にするという方法で負数を表す32ビット整数には意味がありますが、
// このような方法で負数を表さないBigInt値に対しては意味がないからである

//////////////////////////////////////////////////////////////////////////////////////
// 4.9 関係演算子
//////////////////////////////////////////////////////////////////////////////////////

// この節では、JavaScriptの関係演算子について解説する
// 関係円盤氏は2つの値の関係（例えば、「等しい」や「より小さい」、「プロパティかどうか」）を調べて、
// その結果に基づいてtrueまたはfalseを返す
// 関係演算子を返す値は常に論理値になる
// この論理演算値はif文やwhile文やfor文（5章）でプログラムの実行を制御するときによく使われる
// この後、項を分けて、等値演算子、不等演算子、比較演算子、in演算子、instanceof演算子について解説する

//////////////////////////////////////////////////////////////////////////////////////
// 4.9.1 等値演算子と不等演算子
//////////////////////////////////////////////////////////////////////////////////////

// 等値演算子（==）と同値演算子（===）は、2つのオペランドの値が同じかどうか調べる
// 両演算子とも、オペランドには任意の型が使える
// オペランドが等しい場合はtrueを返し、異なる場合はfalseを返すところも同じである
// ただし、等値演算子と同値演算子では「同じ」の定義が異なる
// 同値演算子（===）は、厳密に2つのオペランドが「同一」であるかどうかを調べる
// 等値演算子（==）は、もっと緩やかに型変換を行いながら値を比較して、2つのオペランドが「等しい」かどうか調べる

// 不等演算子（!=）と非同値演算子（!==）は、それぞれ等値演算子（==）と同値演算子（===）の逆の動きをする
// 不等演算子（!=）は、==演算子で2つの値が等しいと判断される場合にfalseを返し、等しくない場合にtrueを返す
// 非同値演算子（!==）は、2つの値が同一の場合にfalseを返し、同一でない場合にtrueを返す
// 4.10章で解説するが、!演算子は論理否定（NOT）演算子を行う
// この演算子と関連付けて、!=を「等しくない」、!==を「同一でない」と考えて覚えるとよい

// =、==、===演算子
// JavaScriptには=、==、===演算子がある
// この代入演算子、等値演算子、同一演算子の違いをよく理解してく必要がある
// そして、コードを書くときには適切な演算子を使うようにすること
// この3つの演算子はすべて「イコール」と読みたくなるが、
// =については「代入する」、==については「等しい」、===については「同値である」と読むようにすると混乱しにくい
// ==演算子は、JavaScriptのレガシーな機能である
// 一般に、バグの温床と考えられている
// ==、!=の代わりに===、!==を使うようにすること

// 3.8章で解説したように、JavaScriptではオブジェクトを値ではなく、参照で比較する
// あるオブジェクトは、そのオブジェクト自身とは等しくなるが、ほかのオブジェクトとは等しくならない
// 2つの異なるオブジェクトが同じ名前と値のプロパティを同じ数だけ持っていたとしても、この2つのオブジェクトは等しいとは判定されない
// 同じ要素を同じ順序でもつ2つの配列も等しいと判定されない

//////////////////////////////////////////////////////////////////////////////////////
// 4.9.1.1 同値演算子
//////////////////////////////////////////////////////////////////////////////////////

// 同値演算子（===）は、オペランドを評価し、次のような規則で型変換を行わずに2つの値を比較する

// ・2つの値の型が異なる場合は、2つの値は等しくないと判定する

// ・2つの値が両方ともnullの場合、また2つの値が両方ともundefinedの場合、2つの値は等しいと判定する

// ・両方の値が論理値のtrueであるか、両方の値が論理値のfalseであれば、等しいと判断する

// ・どちらか一方、または両方ともNaNの場合、等しくないと判定する
// 　NaN値はNaN値自身を含めて、どの値とも等しくならない
// 　xがNaNかどうかを調べるときは、x !== xという式か、isNaN()グローバル関数を使うこと

// ・両方の値が数値で、同じ値を保つ場合は、等しいと判定する
// 　一方の値が0でもう一方の値が-0の場合も等しいと判定する

// ・量の方値が文字列で、同じ位置に同じ16ビット値（3.3章コラム）が含まれる場合、2つの値を等しいと判定する
// 　文字列の長さや内容が異なる場合は、等しくないと判定する
// 　同じ内容で、同じ見た目になるような2つの文字列が、異なる16ビット値でエンコードされている場合、
// 　JavaScriptはUnicodeの正規化処理を行わないので、===演算子や、==演算子ではこの2つの文字列を等しくないと判定する

// ・両方の値が同じオブジェクトや配列、関数を参照していれば、等しいと判定されない
// 　両方の値が異なるオブジェクトを参照している場合は、等しいとは判定されない
// 　両方のオブジェクトがたとえ同じプロパティを持つ場合でも、等しいとは判定されない

//////////////////////////////////////////////////////////////////////////////////////
// 4.9.1.2 型変換を伴う等値演算子
//////////////////////////////////////////////////////////////////////////////////////

// 等値演算子（===）は、同値演算子と同じような処理を行うが、少しる緩やかに比較を行う
// 2つのオペランドの型が異なる場合は、型変換を行った後に、再度比較を行う

// ・どちらも同じ型の場合は、両方の値が同一かを調べる
// 　先ほど説明した方法で値が同一かどうかを調べ、同一であれば等しいと判定する
// 　値が同一でなければ、等しくないと判定する

// ・型が異なる場合は、両方が同じ型になるように変換してから、以下の基準に基づいて、等しいかどうかを判定する

// 　ーどちらか一方の値がnullで他方がundefinedの場合、等しいと判定する

// 　ーどちらか一方の値が数値で他方が文字列の場合、文字列を数値に変換してから比較を行う

// 　ーどちらか一方の値がtrueの場合、trueを１に変換してから比較を行う
// 　　どちから一方の値がfalseの場合、falseを0に変換してから比較を行う

// 　ーどちらか一方の値がオブジェクトで他方が数値または文字列の場合、3.9.3章で紹介したアルゴリズムを使って、
// 　　オブジェクトを基本型に変換してから比較を行う
// 　　オブジェクトを基本型に変換するには、toString()メソッドまたはvalueOf()メソッドが使われる
// 　　コアJavaScriptの組み込みクラスでは、valueOf()変換がtoString()変換おり優先される
// 　　ただし、Dateクラスだけは例外で、常にtoString()変換が行われる
// 　ー上記意外の場合は、等しくないと判定する

// 型変換を伴う等値テキストの例を以下に紹介する

 "1" == true // true

// 2つの値は見た目がまったく異なっているが、この式はtrueになる
// 論理値のtrueがまず1に変換され、文字列の"1"に変換された後、比較が行われる
// 2つの値は同じ数値に変換されたので、この比較は等しい（true）ということになる

//////////////////////////////////////////////////////////////////////////////////////
// 4.9.2 比較演算子
//////////////////////////////////////////////////////////////////////////////////////

// 比較演算子は2つのオペランドの相対的な順序（数値上またはアルファベット順）を調べる
// 比較演算子には以下のようなものがある

// 小なり演算子（<）
// 小なり演算子（<）は、1番目のオペランドが2番目のオペランドより小さいときにtrueを返す
// それ以外のときにはfalseを返す

// 大なり演算子（>）
// 大なり演算子（>）は、1番目のオペランドが2番目のオペランドより大きいときにtrueを返す
// それ以外のときにはfalseを返す

// 小なりイコール演算子（<=）
// 小なりイコール演算子（<=）は、1番目のオペランドが2番目のオペランドに等しいか、あるいはそれより小さいときにtrueを返す
// それ以外のときにはfalseを返す

// 大なりイコール演算子（>=）
// 大なりイコール演算子（>=）は、1番目のオペランドが2番目のオペランドに等しいか、あるいはそれより大きいときにtrueを返す
// それ以外の時にはfalseを返す

// 比較演算子のオペランドには任意の型が指定できる
// しかし、比較は数値と文字列のどちらかの形式で行われるので、数値でも文字列でもないものは、そのどちらかに変換される
// 型変換と比較は次の規則に従う

// ・どちらかのオペランドがオブジェクトの場合、3.9.3章で最後で述べた方法で、オブジェクトは基本型に変換される
// 　つまり、valueOf()メソッドが基本型値を返す場合は、この値が使われる
// 　基本型値を返さない場合は、toString()メソッドの戻り値が使われる

// ・オブジェクトから基本型へ変換の後、両方のオペランドが文字列の場合、この2つの文字列をアルファベット順で比較する
// 　ここで「アルファベット順」とは、文字列を構成する16ビットUnicode値の数値順序になる

// ・オブジェクトから基本型へ変換の後、少なくとも片一方のオペランドが文字列ではない場合、
// 　両方のオペランドが数値に変換され、数値的に比較される
// 　0と-0は等しいと判定される
// 　Infinityは他の数値よりも大きいと判定される
// 　-Infinityは他の数値よりも小さいと判定される
// 　どちらかのオペランドがNaNの場合、またはNaNに変換される場合、比較演算子は常にfalseを返す
// 　算術演算子では通常の値とBigInt値を組み合わせることはできないが、比較演算子では通用の数値とBigInt値を比較することができる

// すでに述べたように、JavaScriptでは文字列は16ビットの整数値の並びであるため、
// 文字列比較は単純に2つの文字列の値を数値的に比較するだけである
// Unicodeで定義されている数値順序は、ある特定の言語やロケールで使われる伝統的な文字順序として一致していない場合もある
// また、文字列は大文字と小文字を区別して比較される
// Unicodeでは（少なくともASCIIの範囲では）大文字は小文字より「小さい」と判定されるので注意すること
// 例えば「Zoo」は「aardvark」よりも小さいことになる

// もっとしっかりとした文字列比較を行いたい場合は、String.localeCompare()メソッドを使用すること
// このメソッドは、ロケール固有のアルファベット順序を考慮に入れて比較を行う
// 大文字と小文字を区別しないで比較したい場合は、まず文字列をすべてString.toLowerCase()メソッドを使って小文字に変換するか、
// String.toUpperCase()メソッドを使って大文字に変換した後、比較をすること
// なお、もっと汎用的で言語を考慮した比較を行いたい場合、Intl.Collatorクラスを使用すること
// Intl.Collatorクラスについては11.7.3章で解説する

// +演算子も比較演算子も、オペランドが数値か文字列化で振る舞いが変わる
// +演算子は、文字列処理を優先する
// オペランドもいずれかが文字列の場合、連結処置が行われる
// 比較演算子は、数値を優先する
// 文字列結合を行うのは、両方のオペランドが文字列の場合のみだけである
// 例をいくつか解説する

1 + 2           // 3: 加算
"1" + "2"       // "12": 連結
"1" + 2         // "12": 2は"2"に変換される
11 < 3          // false: 数値で比較
"11" < "3"      // true: 文字列で比較
"11" < 3        // false: 数値で比較 "11"は11に変換される
"one" < 3       // false: 数値で比較 "one"はNaNに変換される

// 最後に注意するが、小なりイコール演算子（<=）や大なりイコール（>=）は、
// 2つの値が「等しい」かどうかを判定するために等値演算子や同値演算子を使わない
// 小なりイコール演算子は単に「大なり」の反対の意味で、大なりイコール演算子は「小なり」の反対の意味である
// なお、オペランドのどちらかがNaNの場合は、4つの比較演算子はすべてfalseを返す

//////////////////////////////////////////////////////////////////////////////////////
// 4.9.3 in演算子
//////////////////////////////////////////////////////////////////////////////////////

// in演算子は、左辺の値が右辺のオブジェクトのプロパティ名であればtrueを返す
// in演算子の左辺のオペランドは文字列がSymbol、文字列に変換されるもの、右辺のオペランドはオブジェクトでなければいけない

let point = { x: 1, y: 1 };         // オブジェクトの定義
"x" in point                        // true: オブジェクトは"x"という名前のプロパティを持つ
"z" in point                        // false: オブジェクトに"z"という名前のプロパティはない
"toString" in point                 // true: オブジェクトはtoStringメソッドを継承する

let data = [7, 8, 9];               // 要素0, 1, 2をもつ配列
"0" in data                         // true: 配列には要素"0"が存在する
1 in data                           // true: 数値は文字列に変化される
3 in data                           // false: 要素3は存在しない

//////////////////////////////////////////////////////////////////////////////////////
// 4.9.4 instanceof演算子
//////////////////////////////////////////////////////////////////////////////////////

// instanceof演算子は、左辺のオブジェクトが右辺のクラスのインスタンスであればtrueを返す
// instanceof演算子の左辺のオペランドはオブジェクト、右辺のオペランドはクラスを指定するものでなければならない
// 9章で詳しく解説するが、JavaScriptではオブジェクトのクラスはオブジェクトを初期化するコンストラクタ関数で表せる
// したがって、instanceof演算子の右辺のオペランドは関数になる

let d = new Date();             // Date()コンストラクタを使って新しいオブジェクトを生成する
d instanceof Date               // true: dはDate()を使って生成された
d instanceof Object             // true: すべてのオブジェクトはObjectのインスタンス
d instanceof Number             // false: dはNumberオブジェクトではない
let a = [1, 2, 3];              // 配列リテラル構文を使って配列
a instanceof Array              // true: aは配列
a instanceof Object             // true: すべての配列はオブジェクト
a instanceof RegExp             // false: 配列は正規表現ではない

// すべてのオブジェクトはObjectのインスタンスになる
// instanceofで、あるオブジェクトがあるクラスのインスタンスかどうかを判定するときには「スーパークラス（親クラス）」についても考慮する
// instanceofの左辺のオペランドがオブジェクトでない場合、falseを返す
// 右辺のオペランドがオブジェクトのクラスでない場合、TypeErrorがスローされる

// instanceof演算子の動作を理解するためには、JavaScriptの継承機構である「プロトタイプチェーン」について理解する必要がある
// 詳しくは6.3.2章で解説する
// o instanceof fという式を評価するとき、JavaScriptはf.prototypeを評価し、
// oのプロトタイプチェーンの中にこの値が存在するかどうかを検索する
// 存在する場合には、oはfまたはfのサブクラス（子クラス）のインスタンスとなり、演算子はtrueを返す
// f.prototypeがoのプロトタイプチェーンに含まれない場合は、oはfのインスタンスではないので、instanceofはfalseを返す

//////////////////////////////////////////////////////////////////////////////////////
// 4.10 論理演算子
//////////////////////////////////////////////////////////////////////////////////////

// 論理演算子の&&、||、!は論理演算子を行う
// 2つの関係演算式を組み合わせて複雑な式を作成するときによく使われる
// これらの演算子については、これから項を分けて解説する
// この論理演算子を完全に理解するには3.4章で解説した「trueに変換されるもの」と「falseに変換されるもの」という概念について、
// もう一度振り返る

//////////////////////////////////////////////////////////////////////////////////////
// 4.10.1 論理演算子（&&）
//////////////////////////////////////////////////////////////////////////////////////

// &&演算子の理解度は3つのレベルがある
// 最も単純なレベルでは論理演算子（&&）は前のオペランドと後ろのオペランドの両方がtrueの場合のみにtrueになるという理解である
// オペランドの一方もしくは両方がfalseであれば結果もfalseになる

// &&は2つの関係式を組み合わせるときによく使われる

x === 0 && y === 0 // xとyの両方が0のときのみtrueになる

// 関係式は常にtrueまたはfalseになるので、このような使い方をすると、&&演算子自身もtrueまたはfalseを返す
// 関係演算子は&&や||よりも優先順位が高いため、先ほどの式に丸括弧を記述する必要はない

// しかしながら、&&のオペランドは論理値以外であっても問題ない
// JavaScriptではすべての値は「trueに変換される」か「falseに変換されるか」のどちらかである
// 詳しくは3.4章で解説
// 「falseに変換されるもの」はfalseとnull, undefined, 0, -0, NaN, ""である
// ほかの値はすべてのオブジェクトも含めてtrueになる
// &&の次のレベルはtrueに変換されるものと、falseに変換されるものに対する論理積演算子である
// 両方のオペランドがtrueに変換されるものであれば、この演算子はtrueに変換されるものを返す
// それ以外の場合、つまりどちらか、または両方のオペランドがfalseに変換されるものであれば、この演算子はfalseに変換されるものを返す
// JavaScriptでは、論理値が必要な式や文であっても、trueやfalse以外の値を返したとしても、特に問題が生じたりはしない

// 先ほどの説明で、&&演算子が「trueに変換される値」や「falseに変換される値」を返すと説明したが、実際にどういう値が返されるのかは明らかにしていない
// この点を理解したら、&&演算子については免許皆伝です
// &&演算子は、左辺の式をまず評価する
// 左辺の式の値がfalseに変換される値の場合は、式全体の値もfalseに変換される値になる
// そこで、&&演算子は、単純に左辺の式の値だけを返す
// 右辺の式については評価すらしない

// 逆に、左辺の式の値がtrueに変換される値の場合、式全体の値は右辺の式の値に依存する
// 右辺の式がtrueに変換される値であれば、式全体の値はtrueに変換される値になる
// 逆に、右辺の式がfalseに変換される値であれば、式全体の値はfalseに変換される値になる
// したがって、左辺の式の値がtrueに変換される値であれば、&&演算子は右辺の式を評価し、この値を返す

let o = {x: 1};
let p = null;
o && o.x        // 1: 0はtrueと評価されるので、戻り値はo.xになる
p && p.x        // null: pはfalseと評価されるので、それを返すp.xは評価されない

// 重要なことなので、&&演算子が右辺のオペランドのどのような場合に評価して、どのような場合に評価しないのかを理解しておくこと
// 前述したコードでは、変数pにnullが設定されているのでp.xという式が評価されてしまうと、TypeErrorが発生する
// しかし。このコードでは&&をうまく使うことでpがnullやundefinedではなく、trueに変換される場合にのみp.xが評価されるようにしている

// &&のこの振る舞いは、短絡評価とよばれることがある
// このふるまいを意図的に使って、条件付きで実行するようなコードを見かける場合がある

if (a === b) stop();    // a === bの場合のみ、stop()を呼び出す
(a === b) && stop();    // 上の文と同じ処理

// 一般的に&&の右辺で副作用（代入、インクリメント、デクリメント、関数呼び出し）を模帳な式を記述するときは注意が必要
// 左辺の値によって、これらの副作用が生じるかどうかが変わってしまうためである

// このように論理積演算子（&&）の振る舞いは少し複雑だが、普通は単純にtrueに変換されるものと、
// falseに変換されるものとの間で論理演算を行うためだけに使用する

//////////////////////////////////////////////////////////////////////////////////////
// 4.10.2 論理和演算子（||）
//////////////////////////////////////////////////////////////////////////////////////

// 論理和演算子（||）は、オペランドの一方または両方がtrueに変換される値の場合は、trueに変換される値を返す
// これ以外の場合、すなわち両方のオペランドがfalseに変換される値の場合は、falseに変換される値を返す

// このように論理和演算子（||）を単なる論理OR演算子のつもりで使用する人が多いが、論理積演算子（&&）と同じように複雑な振る舞いをするので注意が必要である
// まず、演算子（||）の左辺オペランド（式）を評価する
// この式の値がtrueに変換される場合は、左辺の式の値をそのまま変換せずに返す
// 一方で、左辺の式がfalseに変換される値の場合は、||は右辺のオペランドを評価しこの値を返す

// &&演算子と同じように、右辺の式が評価されない場合があるということを意図的に利用したい場合を除けば、
// 副作用を伴う式を右辺のオペランドに指定しないようにすること

// この振る舞いは、最初のtrueに変換される値を選択したい場合によく使われる

// maxWidthがtrueに変換される値であればこの値を使う
// falseに変換される値であれば、preferencesオブジェクトの値を使う
// この値もtrueに変換される値でなければ、定数を使う
let max = maxWidth || performance.maxWidth || 500;

// maxWidthの値として0を指定しても良い場合は、このコードは正しく動作しない
// 0はfalseに変換される値だからである
// このような場合は、代わりに??演算子（4.13.2章）を使用すること

// ES6よりも前のバージョンでは、パラメータのデフォルト値を指定するために、この慣用句が関数本体中でよく使われている

// oプロパティをpにコピーしてpを返す
function copy(o, p) {
    p = p || {};    // pにオブジェクトが渡されない場合、新たにオブジェクトを生成する
    // ここに関数本体を記述する
}

// しかしながら、ES6以降ではこのような記述をする必要はなくなった
// 関数定義中にfunction copy(o, p={}) { ... }のように記述するだけで、引数にデフォルトの値を指定できるようになったためである

//////////////////////////////////////////////////////////////////////////////////////
// 4.10.3 論理否定演算子（!）
//////////////////////////////////////////////////////////////////////////////////////

// 論理否定演算子（!）は単項演算子である
// オペランドは1つしかない
// !をオペランドの前に置くと、そのオペランドの論理値を反転させる
// 例えば、変数xの値がtrueに変換される値であれば、!xはfalseになる
// xがfalseに変換される値であれば、!xはtrueになる

// &&演算子や!!演算子とは異なり、論理否定演算子（!）は3章で紹介した規則を使ってオペランドを論理値に変換した後、論理を反転させる
// つまり、!演算子が返す値は、trueかfalseだけである
// したがって、変数xに対して、!!xのように2つの論理否定演算子を前置すると、xに格納された任意の型の値を、
// 対応する論理値に変換することができる（3.9.2章）

// 単項演算子として、!演算子は高い優先順位を持つ
// したがって、p && 1のような式の値を反転したい場合は、丸括弧を使って、!(p && q)のように記述しなければいけない
// なお、ここで論理学の2つの定数をJavaScriptの文法で記述しておく

// ド・モルガンの法則
!(p && q) === (!p || !q)    // true: 任意のpとqに対して成立
!(p || q) === (!p && !q)    // true: 任意のpとqに対して成立

//////////////////////////////////////////////////////////////////////////////////////
// 4.11 代入演算子
//////////////////////////////////////////////////////////////////////////////////////

// JavaScriptでは、=演算子を使って、変数やプロパティに値を代入する

i = 0;          // 変数iに0をセットする
o.x = 1;        // オブジェクトoのプロパティxに1をセットする

// 代入演算子（=）の左辺のオペランドは、左辺値である
// つまり、変数またはオブジェクトプロパティ（配列要素を含む）のいずれかである
// 右辺のオペランドは任意の型の任意の値になる
// 代入式の値は右辺の値になる
// 再入演算子（=）には副作用があり、左辺の変数やプロパティには右辺の値が代入される
// 以降、この変数やプロパティを評価すると、この右辺の値になる

// 代入演算子は単純な場合がほとんどだが、大きな式の一部として代入式の値が使われる場合がある
// 例えば、1つの式で代入して比較することもできる

(a = b) === 0

// このような式は、=と==という2つの演算子の違いをはっきりと理解した上で記述すること
// 代入演算子の優先順位は非常に低いため、大きな式の中で代入演算子の値を使う場合には、丸括弧を記述することを忘れないこと

// 代入演算子は、右から左へ結合するので、式の中に複数の代入演算子を記述した場合は、右から左へ評価される
// つまり、以下に示すように1つの値を複数の値に代入することも可能である

i = j = k = 0;  // 3つの変数を0に初期化する

//////////////////////////////////////////////////////////////////////////////////////
// 4.11.1 算術演算を伴う代入演算子
//////////////////////////////////////////////////////////////////////////////////////

// JavaScriptは通常の代入演算子（=）のほかにも、いくつかの代入演算子をサポートしている
// これらの演算子は、代入処理とほかの算術演算を組み合わせたものである
// 例えば、+=演算子は加算という代入という2つの処理を実行する

total += salesTax;

// この式は次の式と同じ意味である

total = total + salesTax;

// +=演算子は数値と文字列の両方に適用できる
// 数値オペランドの場合は加算と代入が行われ、文字列オペランドの場合は連結と代入が行われる

// ほかにも、-=、*=、&=などがある
// 詳細については表4-2を参照

// 一般に、opを演算子とすると、次の形式で記述できる

a op= b

// これは次のように記述したのと同じ意味になる

a = a op b

// ただし、この2つの式には違いがある
// 前者では、式aは一度しか評価されない
// これに対して後者では、aは2回評価される
// aの中で、関数呼び出しやインクリメント円zなしのような副作用がある場合は、前者と後者は異なる結果になる
// 例えば、次の2つの代入式は異なる結果になる

data[i++] += 2;
data[i++] = data[i++] * 2;

//////////////////////////////////////////////////////////////////////////////////////
// 4.12 評価式
//////////////////////////////////////////////////////////////////////////////////////

// 多くのインタプリタ言語と同じように、JavaScriptには、JavaScriptのソースコード文字列を解約する機能がある
// そして、この文字列を評価することで値を生成する
// ソースコード文字列を評価したい場合は、グローバル関数のeval()を使う

eval("3+2")     // 5

// ソースコード文字列を動的に評価する機能は、プログラミング言語にとって強力な機能であるが、実際には必要になる場面はほとんどない
// eval()を使いたくなった場合も、本当に使う必要があるのかどうかをよく考えてみること
// 特に、eval()はセキュリティホールになる可能性がある
// ユーザーが入力した文字列をeval()に渡してはいけない
// JavaScriptのように複雑な言語では、eval()で安全に使えるように、ユーザの入力をサニタイズ（無害化）する方法はない
// このようなセキュリティ上の問題があるため、Webサーバの中には、「Content-Security-Policy」というHTTPヘッダーを使って、
// Webサイト全体でeval()を無効にしているものもある

// 以降では項を分けて、eval()の基本てきな使い方について説明する
// その後、最適化処理にあまり影響がないように機能制限されたeval()について解説する

// eval()は関数か、演算子か
// eval()は関数である
// しかし、eval()は本来演算子であるべきなので本章で解説する
// JavaScriptの初期バージョンからeval()関数は定義されていた
// その後、言語の設計者やインタプリタ開発者により、このeval()関数に制限が加えられ、結果としてさらに演算子のようなものになっている
// 一般的に、関数の中でeval()を呼び出している場合、インタプリタはこの関数を最適化できない
// また、eval()を関数として定義しているために、ほかの名前を付けられるという問題も発生する

let f = eval;
let g = f;

// このようなコードが許されると、インタプリタは、どの関数がeval()を呼び出しているのかが分からなくなり、
// 積極的に最適化を行うことができなくなる
// この問題は、eval()が演算子であれば（予約語であれば）避けられた問題である
// このほかeval()を演算子のようにする制限については、4.12.2章と4.12.3章で解説する

//////////////////////////////////////////////////////////////////////////////////////
// 4.12.1 eval()
//////////////////////////////////////////////////////////////////////////////////////

// eval()の引数は1つである
// 引数として文字列以外の値を渡した場合には、その値がそのまま返される
// 文字列をJavaScriptコードとして解釈する
// 解釈できない場合は、SyntaxErrorをスローする
// 文字列が解釈できた場合には、コードを評価し、文字列中の最後の式または文の値を返す
// 最後の式、または文が値を持たない場合には、undefinedが返される
// 評価される文字列の中から例外をスローしている場合、eval()はその例外をスローし直す

// eval()を呼び出すと、eval()を呼び出したコードの環境（変数）が使われる
// つまり、通常のコードと同じように変数の値を検索し、同じように新しい変数や関数を定義する、ということである
// ある関数の中でローカル変数xを定義しておき、eval("x")という風に呼び出すと、ローカル変数の値が得られる
// eval("x=1")という風に呼び出せば、ローカル変数の値が変更される
// また、eval("var y = 3;")という風に呼び出せば、新たにローカル変数yが宣言される
// 一方、評価する文字列中でletやconstを使って変数や定数を宣言した場合は、変数と定数は評価する文字列中のローカルなものとなる
// つまり、呼び出した側の環境では定義されない

// 同様に以下のようなコードでもローカル関数も宣言できる

eval("function f() { return x+1; }");

// なお、eval()をトップレベルのコードから呼び出した場合は、グローバル変数やグローバル関数に対して処理を行うことになる

// eval()に渡すす文字列は、この文字列だけで構文的に意味のあるものでなければならない
// つまり、コード文字列を使って、関数の一部を書き換えるようなことはできない
// 例えば、eval("return;")と記述しても意味がない
// returnは関数中でしか意味がない
// 評価する文字列が呼び出し元の関数と同じ変数環境を使うと説明したが、これは文字列自体が関数の一部になるという意味ではない
// なお、文字列が単独のスクリプトとして意味があれば(x=0のような短いスクリプトでも）、eval()の引数として問題ない
// それ以外の場合は、SyntaxErrorがスローされる

//////////////////////////////////////////////////////////////////////////////////////
// 4.12.2 グローバルeval()
//////////////////////////////////////////////////////////////////////////////////////

// eval()がローカル変数を変更できるために、JavaScriptの最適化処理において問題となる
// この問題への対策として、インタプリタはeval()を呼び出す関数については最適化処理をあまり行わないようにしている
// しかし、スクリプト中でeval()の別名を定義し、この別名を使って関数を呼び出している場合、JavaScriptインタプリタはどのような処理をするのか
// JavaScript仕様では「eval」以外の名前でeval()が呼び出された場合は、トップレベルのグローバルコードとして文字列を評価すると規定している
// 評価されたコード中から、グローバル変数やグローバル関数を定義したり、グローバル変数を設定したりできるが、
// 呼び出した関数のローカル変数を仕様したり変更したりはできない
// これにより、呼び出した関数に対する最適化処理に影響が出ないようにしている

// eval()関数を「eval」という名前で呼び出した場合、「直接eval」と呼ぶ（「eval」を予約語のように使う場合である）
// 直接eval()を呼び出した場合は、呼び出しコンテキストの変数環境を使う
// このほかの場合(関節呼び出し)は、環境変数としてグローバルオブジェクトを使う
// ローカル変数や関数の読み書き、定義はできない（直接呼び出しでも、関節呼び出しでも、新しい変数を定義できるのはvarのみである）
// 評価する文字列中でletやconstを使って変数や定数を作成た場合は、変数や定数を評価する文字列ローカルとなる
// 呼び出し環境やグローバル環境を変更することはない

const geval = eval;             // 別名を使うとグローバルevalになる
let x = "global", y = "global"; // 2つのグローバル変数
function f() {                  // この関数はローカルevalを使う
    let x = "local";            // ローカル変数を定義する
    eval("x += 'changed';");    // 直接evalではローカル変数を設定する
    return x;                   // 変更されたローカル変数が返される
}
function g() {                  // この関数はグローバルevalを使う
    let y = "local";            // ローカル変数
    geval("y += 'changed';");   // 間接evalでは、グローバル変数を設定する
    return y;                   // 変更されていないローカル変数が返される
}
console.log(f(), x); // ローカル変数が変更される "localchanged global"が出力される
console.log(g(), y); // グローバル変数が変更される "local globalchanged"が出力される

// グローバルevalの機能は、単なる、最適化のための妥協の産物というわけではない
// この機能は非常に有利である
// グローバルevalを使えば、コード文字列を独立したトップレベルのスクリプトとして実行できる
// 本項の最初でも述べたが、コード文字列を評価しなければならない場合はあまりない
// しかし、必要となる場合があるとしたら、ローカルevalではなくグローバルevalを使う場合である

//////////////////////////////////////////////////////////////////////////////////////
// 4.12.3 strictモードでのeval()
//////////////////////////////////////////////////////////////////////////////////////

// strictモード(5.6.3章)ではeval()関数の振る舞いにさらに制限が課せられている
// 「eval」という識別子の利用についても制限が追加されている
// strictモードのコードからeval()が呼び出されたとき、または"use strict"ディレクティブかた始まるコード文字列が評価されたとき、
// eval()はプライベートな変数環境を使ってローカルevalを行う
// 言い換えると、strictモードでは、評価されたコードからローカル変数を取得したり、変更したりできるが、
// ローカルスコープ中に新しい変数や関数を定義することはできない

// さらに、strictモードでは「eval」を事実上予約語にすることで、eval()をもっと演算子のような扱いにしている
// eval()関数を新しい関数で上書きすることはできない
// 「eval」という名前で、変数や関数、関数パラメータ、キャッチブロックのパラメータを宣言することもできない

//////////////////////////////////////////////////////////////////////////////////////
// 4.13 そのほかの演算子
//////////////////////////////////////////////////////////////////////////////////////

// JavaScriptは、そのほかにもいくつかの演算子をサポートしている、以下順に解説する

//////////////////////////////////////////////////////////////////////////////////////
// 4.13.1 条件演算子(?:)
//////////////////////////////////////////////////////////////////////////////////////

// 条件演算子(?:)はJavaScriptで唯一の三項演算子である
// 三項演算子というのは、オペランドを3つ取る意味である
// この演算子は?:と表記されるが、実際の使い方は少し違う
// 先頭のオペランドの後ろに?を置き、その後ろに2番目のオペランド、その後ろに:を置いて、最後に3番目のオペランドを記述する

x > 0 ? x : -x // xの絶対値

// 条件演算子のオペランドには任意の方の値を指定できる
// 先頭のオペランドは論理値として評価される
// 先頭のオペランドの値がtrueに変換できる場合は、2番目のオペランドの値を評価し、その値を返す
// 先頭のオペランドの値がfalseに変換できる場合は、3番目のオペランドの値を評価し、その値を返す
// つまり、2番目のオペランドか、3番目のオペランドのいずれかのみ評価され、両方が評価されることはない

// if文(5.3.1章)を使用しても同じなことが実現できるが、?:演算子のほうが簡単である
// 典型的な例では、変数が定義されているかどうか(trueと変換される値を持つかどうか)をチェックし、定義されていなければその値を使用し、
// 定義されていなければデフォルトの値を使用するという使い方である

greeting = "hello " + (username ? username : "there");

// これと同じことはif文でも可能だが、次の例のように長くなってしまう

greeting = "hello ";
if (username) {
    greeting += username;
} else {
    greeting += "there";
}

//////////////////////////////////////////////////////////////////////////////////////
// 4.13.2 ファーストデファインド演算子(??)
//////////////////////////////////////////////////////////////////////////////////////

// ファーストデファインド(First-defined)演算子(??)はオペランドのうち定義されている最初のオペランドを返す
// 左辺のオペランドがnullでもundefinedでもない場合は、左辺の値を返す
// nullまたはundefinedの場合は、右辺のオペランドを返す
// &&演算子や||演算子と同じように、??演算子も最初のオペランドがnullまたはundefinedの場合にのみ2つ目のオペランドを評価する
// 式aに副作用がない場合は、a ?? bという式は次の式と同じ意味になる

(a !== null && a !== undefined) ? a : b

// 最初のtrueと変換される値ではなく、最初の定義されたオペランドを選択したい場合は、||演算子(4.10.2章)の代わりに??演算子を使う方が便利である
// ||演算子は論理OR演算子という意味だが、次のようなコードの最初のfalseには変換されないオペランドを選択するときにもよく使われている

// maxWidthがtrueに変換される値であればこの値を使う
// falseに変換される値であれば、preferencesオブジェクトの値を使う
// この値もtrueに変換される値でなければ、定数を使う
let max = maxWidth || preferences.maxWidth || 500;

// この記述方法が問題となるのは、ゼロや空文字、falseなどのfalseに変換される値が有効な値の場合である
// 先ほどのコードを例にすると、もしもmaxWidthがゼロの場合、maxWidthの値が無視される
// しかし、||演算子を??演算子に変更すれば、ゼロが有効となる式にすることができる

// maxWidthが定義されていればこの値を使う
// 定義されていなければ、preferencesオブジェクトの値を使う
// この値も定義されていなければ、定数を使う
let max = maxwidth ?? preferences.maxWidth ?? 500;

// もう少し例を紹介して、最初のオペランドがfalseに変換される値の場合に、??演算子がどのような動きをするのか解説する
// 最初のオペランドがfalseに変換される値であっても定義されていれば、??演算子はこの最初のオペランドを返す
// 最初のオペランドがnullまたはundefinedの場合のみ、2つ目のオペランドを評価し、演算子の値として返す

let options = { timeout: 0, title: "", verbose: false, n: null };
options.timeout ?? 1000         // 0: オブジェクトで定義されている
options.title ?? "undefined"    // "": オブジェクトで定義されている
options.verbose ?? true         // false: オブジェクトで定義されている
options.quiet ?? false          // false: プロパティが定義されていない
options.n ?? 10                 // 10: プロパティの値がnull

// この例で、??演算子の代わりに||演算子を使った場合、timeout、title、verboseの式の値は異なる値になる

// ??演算子は、&&演算子や||演算子と似ている
// しかし、この2つの演算子よりも優先度は高くもなく、低くもない
// &&演算子や||演算子と一緒に??演算子を使いたい場合は、丸括弧をつかって、どの演算子を最初に処理したいのかを明示するようにすること

(a ?? b) || c   // ??が最初で、その次に||
a ?? (b || c)   // ||が最初で、その次に??
a ?? b || c     // SyntaxError: 丸括弧を必ず記述しなければならない

// ??演算子はES2020で規定されている
// 2020年初頭の段階では、すべての主要なブラウザの最新バージョン、またはβバージョンで実装されている
// この演算子は正式には「Null合体演算子」と呼ばれている
// しかし、この演算子はオペランドの1つを選択するが、「合体」させることはないため、筆者としてはこの用語は使わないようにしている

//////////////////////////////////////////////////////////////////////////////////////
// 4.13.3 typeof演算子
//////////////////////////////////////////////////////////////////////////////////////

// typeofは単項演算子である
// オペランドは1つだけである
// オペランドの値は任意である
// typeof演算子は、オペランドのデータ型を示す文字列を返す
// JavaScriptのさまざまな値に対してtypeof演算子を使ったときの値を、表4-3にまとめる

// typeof演算子の使用例を紹介する

// 値が文字列の場合は、引用符で囲む
// 文字列ではない場合は、文字列に変換する
(typeof value === "string") ? "'" + value + "'" : value.toString()

// オペランドの値がnullの場合でも、typeofは"object"という文字列を返すことに注意すること
// nullとオブジェクトを区別したい場合には、明示的にnullかどうかテストするようにすること

// JavaScriptでは、関数はオブジェクトの一種だが、関数は戻り値を持つので、ほかのオブジェクトとは異なると判断し、
// typeof演算子は"function"という文字列を返す

// オペランドが関数以外のオブジェクトと配列の場合は、typeof演算子は"object"(オブジェクト型)としか返さないため、
// オブジェクト型とそのほかの基本型とを区別することしかできない
// どのクラスのオブジェクトであるかを知るには、別の手法が必要である
// 例えば、instanceof演算子(4.9.4章)やclass属性(14.4.3章)、constructorプロパティ(9.2.2章、14.3章)を使う

