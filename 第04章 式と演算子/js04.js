"use strict";

//////////////////////////////////////////////////////////////////////////////////////
// 4.1 単項式
//////////////////////////////////////////////////////////////////////////////////////

// 最も単項な式は他の式を含まない式である
// このような式を単項式と呼ぶ
// JavaScriptでの単項式としてはリテラル（定数値）、JavaScriptのキーワード、変数参照がある

// リテラルとしてはプログラム中に直接埋め込まれた定数値である

1.23        // 数値リテラル
"hello"     // 文字列リテラル
/pattern/   // 正規表現リテラル

// JavaScriptでの数値リテラルは3.2章で解説済み
// 文字列リテラルについては3.3章で解説済み
// 正規表現リテラルについては3.3.5章で概要を解説済み
// 詳細については11.3章で解説する

// JavaScriptの予約語には単項式として使えるものがある

true        // 論理値のtrueの値に評価される
false       // 論理値のfalseの値に評価される
null        // null値に評価される
this        // 「現在の」オブジェクトに評価される

// true, false, nullについては3.4章と3.5章で解説済み
// 他のキーワードと異なり、thisは定数ではない
// プログラム中のさまざまな場所で、さまざまな値に評価される
// thisキーワードはオブジェクト指向プログラミングでよく使われるキーワードである
// メソッド本体でthisを使えば。メソッドが呼び出されたオブジェクトを参照できる
// thisについて詳しくは4.5章、8章(8.2.2章)、9章で解説する

// 最後に紹介する単項式は変数や定数、グローバルオブジェクトのプロパティ参照である

i           // 変数iの値に評価される
sum         // 変数sumの値に評価される
undefined   // グローバルオブジェクトの「undefined」プロパティの値に評価される

// プログラム中に識別子が現れた場合、JavaScriptは変数または定数、グローバルオブジェクトのプロパティと認識し、値を検索する
// 該当する名前の変数が存在しない場合、存在しない変数を評価するとReferenceErrorがスローされる

//////////////////////////////////////////////////////////////////////////////////////
// 4.2 オブジェクトと配列の初期化子
//////////////////////////////////////////////////////////////////////////////////////

// オブジェクトと配列の初期化子とは、新たに生成されるオブジェクトや配列の値となる式のことである
// このような初期化子は「オブジェクトリテラル」や「配列リテラル」と呼ばれることがある
// しかし、本当のリテラルとは異なり単項式ではない
// なぜならプロパティの値や要素の値を指定するために複数の式が含まれるからである
// 配列の初期化子のほうがいくぶん単純であるためこちらから解説する

// 配列初期化子とは、カンマで区切った式のリストを角括弧で囲んだものである
// 配列の初期化子の値は、新たに生成された配列になる
// この配列の要素は、カンマで区切られた式の値に初期化される

[]          // 空の配列 角括弧中に式がない場合、要素がないことを意味する
[1+2, 3+4]  // 要素を2つ持つ配列 1つ目の要素が3 2つ目の要素が7

// 配列初期化子中の要素として、配列初期化子を記述しても構わない
// この場合、入れ子になった配列が生成される

let matrix = [[1, 2, 3], [4, 5, 6], [7, 8, 9]];

// 配列初期化子が評価されるたびに、配列初期化子中の要素の式も評価される
// つまり、配列初期化子の値は、評価されるたびに異なる可能性がある

// 未定義の要素を配列リテラル中に含めたい場合、カンマの値を省略する
// 例えば、次の例は要素を5つもつが、3つの要素は未定義の要素になる

let sparseArray = [1,,,,5];

// 配列初期化子の最後の式の後にカンマを1つ記述しても構わない
// この場合、未定義要素は作成されない
// ただし、最後の式より後のインデックスに対して配列アクセスを行うと、未定義値と評価される

// オブジェクト初期化子は、配列初期化子と同じような書式だが、角括弧の代わりに中括弧を使い、
// 各式の前にはプロパティ名とコロンを記述する

let p = {x: 2.3, y: -1.2};     // 2つプロパティを持つオブジェクト
let q = {};                     // プロパティを持たない空のオブジェクト
q.x = 2.3; q.y = -1.2;          // これでqはpと同じプロパティを持つ

// ES6ではオブジェクトリテラルにもっと高機能な構文が使える
// 詳しくは6.10章で解説
// オブジェクトリテラルは次のように入れ子にできる

let rectangle = {
    upperLeft: {x: 2, y: 2},
    lowerRight: {x: 4, y: 5}
};

// オブジェクト初期化子（オブジェクトリテラル）と配列初期化子（配列リテラル）については6章、7章で解説

//////////////////////////////////////////////////////////////////////////////////////
// 4.3 関数定義式
//////////////////////////////////////////////////////////////////////////////////////

// 関数定義式は、JavaScriptの関数を定義する
// この式の値は新たに定義される関数になる
// オブジェクト初期化子が「オブジェクトリテラル」と呼ばれるのと同じように、関数定義式も「関数リテラル」と呼ぶ
// 関数定義式は、一般的にはfunctionキーワードに続いて、カンマで区切って0個以上の識別子（パラメータ名）を丸括弧中に記述し、
// 中括弧中にJavaScriptコードブロック（関数本体）を記述する

// この関数は引数として渡された値の自乗を返す
let square = function(x) {
    return x * x;
};

// 関数定義式には無名を記述できる
// 関数は、関数定義式のかわりに、関数分を使って定義することもできる
// また、ES6以降では「アロー関数」というコンパクトな構文を使うこともできる
// 関数定義の詳細については8章で解説

//////////////////////////////////////////////////////////////////////////////////////
// 4.4 プロパティアクセス式
//////////////////////////////////////////////////////////////////////////////////////

// プロパティアクセス式は、オブジェクトプロパティの値、または配列の要素の値に評価される
// JavaScriptにはプロパティ用に2つの構文が用意されている

式.識別子
式[式]

// 前者の方法では、式の後にピリオドと識別子を記述している
// 式がオブジェクトを指定し、識別子でアクセスしたいプロパティの名前を指定する
// 後者の方法では、最初の式（オブジェクトまたは配列になる）の後に、角括弧で囲んだ式が続く
// この2番目の式で、アクセスしたいプロパティ名や、アクセスしたい配列要素のインデックスを指定する

let o = {x: 2, y: {z: 3}};      // 例となるオブジェクト
let a = [o, 4, [5, 6]];         // オブジェクトを含む配列の例
o.x                             // 1: 式oのプロパティxの値
o.y.z                           // 3: 式0.yのプロパティzの値
o["x"]                          // 1: オブジェクトoのプロパティxの値
a[1]                            // 4: 式aのインデックス1の要素の値
a[2]["1"]                       // 6: 式a[2]のインデックス1の要素の値
a[0].x                          // 1: 式a[0]のプロパティxの値

// どちらのプロパティアクセス式を使っても、.や[の前の式がまず評価される
// 評価した値がnullやundefinedになった場合、TypeErrorがスローされる
// この2つの値はJavaScriptでプロパティを持てないからである
// オブジェクト式の後に、ドットと識別子が続く場合、識別子で指定されたプロパティ名が検索され、この値がプロパティアクセス式全体の値となる
// オブジェクト式の後に角括弧が続く場合、2番目の式を評価し文字列に変換する
// この文字列と同じ名前のプロパティの値が、プロパティアクセス式全体の値になる
// どちらの場合も、指定された名前のプロパティが存在しない場合は、プロパティアクセス式の値はundefinedになる

// 2つの方法を比べると、.識別子構文の方が簡単である
// ただし、この形式が使えるのは、アクセスしたいプロパティの名前が識別子として使え、またプロパティを書くときにその名前を知っているときだけである
// 例えば、プロパティ名が予約語であったり、空白や句読点文字を含んでいたりする場合や、
// （配列などで）数値の場合は、角括弧を使って記述しなければならない
// また、プロパティ名が静的に決まるのではなく、計算結果できまるような場合にも角括弧が使われる（6.3.1章参照）
// オブジェクトとプロパティについては6章で解説
// 配列と要素については7章で解説

//////////////////////////////////////////////////////////////////////////////////////
// 4.4.1 条件付きプロパティアクセス
//////////////////////////////////////////////////////////////////////////////////////

// ES2020では次に示すようなプロパティアクセス式が新たに2種類追加された

式?.識別子
式?.[式]

// JavaScriptではnullとundefinedだけがプロパティを持たない値である
// .や[]という通常のプロパティアクセス式を使った場合、左側の式がnullやundefinedに評価された場合、TypeErrorがスローされてしまう
// ?.や?.[]構文を使うとこのようなエラーを防ぐことができる

// a?.bを例にとって説明する
// もしもaがnullまたはundefinedの場合、この式はundefinedと評価され、プロパティbをアクセスしない
// もしもaが何らかの値を保つ場合、a?.bはa.bを評価したのと同じ値に評価される
// （もしも、aがbという名前のプロパティを持たない場合、この値はundefinedになる）

// この形式のプロパティアクセス式は「オプショナルチェイニング」と呼ばれることもある
// 次のように長く連結（チェイン）されたプロパティアクセス式で使えるものだからである

let a = { b: null };
a.b?.c.d                // undefined

// aはオブジェクトなので、a.bは正当なプロパティアクセス式である
// しかし、a.bの値はnullなので、a.b.cはTypeErrorをスローする
// .の代わりに?.を使うことでTypeErrorがスローされないようになり、a.b?.cはundefinedと評価される
// また、(a.b?.c).dという式は、undefined値のプロパティにアクセスすることになるので、TypeErrorがスローされる
// ただし、丸括弧をつけないでa.b?.c.dと記述した場合は、単純にundefinedと評価され、TypeErrorはスローされない
// これが「オプショナルチェイニング」の非常に重要な機能である
// ?.の左辺にある式がnullまたはundefinedの場合、式全体が即座にundefinedと評価される
// 以降のプロパティアクセスは行われない

// もちろんa.bがオブジェクトでこのオブジェクトがcという名前のプロパティを持っていない場合、a.b?.c.dはTypeErrorをスローする
// この場合は、次のように条件付きプロパティアクセスをもう1つ追加する

let a = { b: {} };
a.b?.c?.d           // undefined

// []の代わりに?.[]と記述しても条件付きプロパティアクセスが行われる
// a?.[b][c]という式では、aの値がnullまたはundefinedの場合、式全体が即座にundefinedと評価される
// この場合、bやcという式は評価されない
// どちらかの式が副作用を持つような式の場合も、その副作用は実行されない

let a;          // この変数を初期化し忘れている
let index = 0;
try {
    a[index++]; // TypeErrorをスローする
} catch(e) {
    index       // 1: TypeErrorがスローされる前にインクリメントが実行される
}
a?.[index++]    // undefined: aがundefinedなので
index           // 1: ?.[]は即座に値を評価するのでインクリメントは行われない
a[index++]      // !TypeError: 未定義値にインデックスは指定できない

// 条件付きプロパティアクセス(?.と?.[])はJavaScriptの最新機能の1つである
// 2020年初頭段階では、この構文は主要ブラウザの最新バージョンまたはβバージョンでサポートされている

//////////////////////////////////////////////////////////////////////////////////////
// 4.5 呼び出し式
//////////////////////////////////////////////////////////////////////////////////////

// 呼び出し式は、JavaScriptにおいて関数やメソッドを呼び出す（実行する）ための構文である
// まず、呼び出される関数を指定するための関数式を記述する
// この関数式の後に、開き丸括弧を記述し、カンマで区切って0個以上の引数式を記述し、最後に閉じ丸括弧を記述する

f(0)                // fは関数式、0は引数式
Math.max(x, y, z)   // Math.maxは関数、 x、ｙ，ｚは引数
a.sort()            // a.sortは関数、引数はない

// 引き出し式が評価されるときは、まず関数式が評価され、続いて引数式が評価され、引数の値のリストが生成される
// 関数式の値が関数にならない場合、TypeErrorがスローされる
// 続いて、引数値が関数定義時に指定されたパラメータに代入され、関数本体が実行される
// 関数は、return文を使うことで値を返すことができる
// この値が呼び出し式の値となる
// return文がない場合には、呼び出し式の値はundefinedになる
// 関数呼び出しの詳細については8章で解説する
// 8章では引数式の数が関数定義時のパラメータの数と一致しなかった場合の挙動についても解説する

// 呼び出し式は一対の丸括弧と、引き丸括弧の前の式から構成される
// この式がプロパティアクセス式の場合には、メソッド呼び出しになる
// メソッド呼び出しの場合は、プロパティアクセスの対象となるオブジェクトや配列がthisキーワードの値となる
// そして、このthisの値を関数本体で利用できるようになる
// このような構造により、オブジェクト指向プログラミング風に関数（オブジェクト指向には「メソッド」）から、
// オブジェクトを操作できるようになる
// 詳しくは9章で解説する

//////////////////////////////////////////////////////////////////////////////////////
// 4.5.1 条件付き呼び出し
//////////////////////////////////////////////////////////////////////////////////////

// ES2020では()の代わりに?.()を使って関数を呼び出すこともできる
// 通常の関数呼び出しでは、丸括弧の左側がnullまたはundefined、関数ではない値であった場合、TypeErrorがスローされる
// ?.()呼び出し構文を使った場合、?.の左側の式がnullやundefinedに評価された場合、関数呼び出し式全体がundefinedと評価される
// 例外はスローされない

// 配列オブジェクトのsort()メソッドには、オプションの引数として関数を渡すことができる
// この関数で、配列要素をソートする順序を定義する
// ES2020より前の使用では、sort()のように関数オプションの引数として受け取るメソッドを記述したい場合は、次の例のように、
// if文を使って関数引数が定義されているかどうかを確認した後に、if文の本体で関数を呼び出すようにしていた

function square(x, log) {       // 第2引数はオプションの関数

    if(log) {                   // オプションの関数が渡されていれば
        log(x);                 // その関数を呼び出す
    }
    return x * x;               // 引数の自乗を返す

}

// しかし、ES2020の条件付き呼び出し構文を使えば、実際に呼びさせる値がある場合にのみ呼び出しが行われるので、
// ?.()を使って単純に関数を呼び出すだけで住む

function square(x, log) {       // 第2引数はオプションの関数

    log?.(x);                   // 関数が渡されていればその関数を呼び出す
    return x * x;               // 引数の自乗を返す

}

// なお、?.()が確認するのは左側の式がnullまたはundefinedかどうかだけである
// 関数かどうかは確認しない
// 先ほどの例のsquare()関数も引数として数値を2つ渡せば例外がスローされる

// ?.()を使った関数呼び出しは条件付きプロパティアクセス式(4.4.1章)と同じような動きをする
// ?.の左側がnullまたはundefinedの場合、丸括弧の中の引数式はすべて消化されない

let f = null, x = 0;
 try {
    f(x++);         // fはnullなのでTypeErrorをスローする
 } catch(e) {
    x               // 1: 例外がスローされる前にxがインクリメントされる
 }
 f?.(x++)           // undefined: fがnullの場合、例外はスローされない
 x                  // 1: 引数は評価されないので、インクリメントは行われない

// 条件付き呼び出し式は、関数と同じようにメソッドを使える
// ただしメソッド呼び出しについてはプロパティアクセスを伴うため、次の式の違いを理解すること

o.m()               // 通常のプロパティアクセス、通常の呼び出し
o?.m()              // 条件付きプロパティアクセス、通常の呼び出し
o.m?.()             // 通常のプロパティアクセス、条件付き呼び出し

// 最初の式では、oはプロパティmを持つオブジェクトでなければならない
// また、プロパティmは関数でなければならない
// 2つ目の式は、oがnullやundefinedの場合、この式全体はundefinedに評価される
// しかし、oが何らかの値を持つ場合、プロパティmの値は関数でなければならない
// そして、3つ目の式ではoはnullやundefinedであってはならない
// oがプロパティmを持たなかったり、プロパティmの値がnullであったりした場合、この式全体はundefinedに評価される

// ?.()を使った条件付き呼び出しはJavaScriptの最新機能の1つである
// 2020年初頭の段階では、この構文は多くの主要なブラウザの最新バージョンやβバージョンで実装されている

//////////////////////////////////////////////////////////////////////////////////////
// 4.6 オブジェクトの生成
//////////////////////////////////////////////////////////////////////////////////////

// オブジェクト生成式は新たにオブジェクトを生成し、コンストラクタと呼ばれる関数を呼び出して、
// オブジェクトのプロパティを初期化する
// オブジェクト生成式は呼び出し式と非常に似ている
// ただし式の前にnewキーワードを記述する点が異なる

new Object()
new PointerEvent(2, 3)

// オブジェクト生成式中のコンストラクタ関数に引数を渡さない場合は、丸括弧を省略しても構わない

new Object
new Date

// オブジェクト生成式の値は、新たに生成されたオブジェクトになる
// コンストラクタについては9章で詳しく解説する

//////////////////////////////////////////////////////////////////////////////////////
// 4.7 演算子の概要
//////////////////////////////////////////////////////////////////////////////////////

// JavaScriptにおいて、演算子は算術式や比較式、論理式、代入式なので使われる
// 演算子の一覧表を表4-1に示す

// ほとんどの演算子は+や=などの記号で表せる 
// しかし、deleteやinstanceofのようにキーワードで表される演算子もある
// キーワードで表される演算子も、記号で表せる演算子と同じく普通の演算子である
// 単に読みやすい表記になっているだけである

// 表4-1は演算子の優先順位順にまとめている
// 初めの方に記述している演算子のほうが、後ろに記述している演算子より優先順位が高い
// 表中の横線で、演算子の優先順位が変わる
// A(associativity)は式の結合性を記す
// Lは左から右の順(left-to-right)で評価する、Rは右から左の順(right-to-left)で評価するという意味
// Nという列はオペランドの数を表す
// 型という名前の列には、想定するオペランドの方と、→の後に演算子の結果の型を列挙している
// 以下の項では、優先順位や結合性、オペランドの型という概念について説明する
// その後に各演算子について説明する

// 表4-1 JavaScript演算子.png 参照

//////////////////////////////////////////////////////////////////////////////////////
// 4.7.1 オペランドの数
//////////////////////////////////////////////////////////////////////////////////////

// 演算子はオペランドの数で3種類に大別できる
// 1つは二項演算子である
// 蒸散演算子（*）などがそうで、2つの式を組み合わせて、より複雑な1つの式を作る
// 操作対象となる終えpランド（被演算子）が2つ必要なので、二項演算子と呼ばれる
// 2つ目は単項演算子である
// 1つの式をもっと複雑な別の式に変換する
// 例えば-xという式の-がそうで、この演算子はオペランドxに対して符号反転を実行する
// 最後の1つは三項演算子である
// JavaScriptで使用できる演算子は、条件演算子（?:）だけである
// ?:は3つの式を組み合わせて1つの式を作れる演算子である

//////////////////////////////////////////////////////////////////////////////////////
// 4.7.2 オペランドと演算結果の型
//////////////////////////////////////////////////////////////////////////////////////

// 任意の型の値を処理できる演算子もあるが、多くの演算子はオペランドとして特定の型を必要としている
// また、同じように多くの演算子はある特定の型の値を返す
// 表4-1の「型」列にオペランドの型と、演算子の演算結果の型を示す
// 矢印の前がオペランドの方で、矢印の後が演算結果の型である

// JavaScriptの演算子は必要に応じてオペランドの型を変換する（3.9章）
// 乗算演算子（*）はオペランドとして数値を必要とする
// しかし、"3" * "5"という式は全く問題ない
// JavaScriptがオペランドを数値に変換するためである
// この式の値は15になり、文字列の"15"ではない
// また、JavaScriptでは値は「trueに変換されるもの」または「falseに変換されるもの」のどちらかになる
// したがって、オペランドとして論理値が必要な演算子でも任意の型のオペランドに対して問題なく動作する

// オペランドの型によって動きが変わる演算子もいくつかある
// 例えば、+演算子の場合、オペランドの型が数値なら加算を実行するが、オペランドの型が文字列であれば連結処理を行う
// 同じように、<などの比較演算子はオペランドの型によって、数値の大小で比較したり、アルファベット順で比較したりする
// 個々の演算子についての説明の中で必要とする型やどのような型変換が行われるかについても解説する

// 表4-1を見ると、代入演算子などいくつかの演算子で、オペランドの型として「左辺値」を必要とするものがある
// 左辺値とは、昔から使われている用語で「代入演算子の左辺に記述して問題ない式」という意味である
// JavaScriptの場合、変数やオブジェクトのプロパティ、配列の要素が左辺値になる

//////////////////////////////////////////////////////////////////////////////////////
// 4.7.3 演算子の副作用
//////////////////////////////////////////////////////////////////////////////////////

// 2 * 3のような単純な式を評価したとしても、プログラムの状態は何も変化しない
// また、今後行う計算にも、この式の評価は何も影響しない
// しかし、式の中には副作用を持つものがあり、その後の評価結果を変えてしまう場合がある
// 代入演算子が最もわかりやすい例で、変数やプロパティに値を代入すれば、今後その値やプロパティを使う式の値が変化する
// 同じように、インクリメント演算子（++）やデクリメント演算子（--）も暗黙的に代入を行うので副作用が生じる
// delete演算子も副作用があり、プロパティを削除することは、プロパティにundefinedを代入するのとほぼ同じ意味になるからである

// JavaScriptではこのほかの演算子には副作用はない
// ただし、関数呼び出し式やオブジェクト生成式は、関数中やコンストラクタ本体で前述したような演算子が使われた場合に副作用を持つことになる

//////////////////////////////////////////////////////////////////////////////////////
// 4.7.4 演算子の優先順位
//////////////////////////////////////////////////////////////////////////////////////

// 表4-1に列挙した演算子は、優先順位の高いものから順に並べている
// 同じ優先順位のものは、横線を引いてグループ分けしている
// 演算子が複数ある場合に、どの演算子から演算を行うかが、この優先順位で制御される
// つまり、表の上の方に挙げている優先順位の高い演算子から処理が行われる

w = x + y * z;

// 乗算演算子*のほうが加算演算子+より優先順位が高いので、まず乗算が行われ、次に加算が行われる
// 代入演算子=は優先順位が最も低いので、右辺の処理がすべて終了した後に実行される

// 優先順位を変更したい場合は、丸括弧()を使用する
// 上記の例で加算を実行してから乗算を実行したい場合は次のようにする

w = (x + y) * z;

// プロパティアクセス式と呼び出し式は、表4-1のすべての演算子より優先順位が高くなる

// myはfunctionsという名前のプロパティを持つ
// このプロパティの値は、関数の配列
// 数値x番目の関数を呼び出して、引数としてyを渡す
// その後、戻り値ｗの型を調べる

typeof my.functions[x](y)

// typeofは優先順位が最高の演算子の1つだが、プロパティアクセスや配列インデックス、関数呼び出しがまず実行され、その結果に対して、typeof演算が行われる
// これらの処理はすべて、演算子よりも優先度が高いものである

// 演算子の優先順位がよく分からない場合は、丸括弧を使用して明示的に評価順序を指定することをお勧めする
// とりあえず、まず乗算と除算が行われ、次に加算と減算が行われ、最後に代入処理が行われることを覚える

// JavaScriptに新しい演算子が追加されたとき、この優先順位の規則に従うものばかりではない
// ??演算子(4.13.2章)は表の中では||や&&演算子よりも優先順位が低いことになっている
// しかし、実際には??演算子と||、&&演算子の優先順位は定義されていない
// ES2020では、??演算子と||、&&演算子を組み合わせる場合は、丸括弧を明示的に使わなければならない
// 同じように新たに追加された**演算子は、単項マイナス演算子と優先順位が明確に定義されていない
// べき乗と負号の組み合わせは丸括弧を使わなければならない

//////////////////////////////////////////////////////////////////////////////////////
// 4.7.5 演算子の結合性
//////////////////////////////////////////////////////////////////////////////////////

// 表4-1でA(associativity)の列は演算子の結合性を示している
// A列のL(left-to-right)は左から右に演算子を結合するという意味である
// 同様にR(right-to-left)は右から左へ演算子を結合するという意味である
// このようなルールは優先順位が同じ演算子の実行順序を決めるときに必要になる
// Lが指定されていれば、左から右へ順に処理される

w = x - y - z;

// 減算演算子は左から右に処理されるため、次のように丸括弧を記述したのと同じである

w = ((x - y) - z);

// 一方次の例を見る

y = a ** b ** c;
x = ~-y;
w = x = y = z;
q = a?b:c?d:e?f:g;

// べき乗演算子や単項演算子、代入演算子、条件演算子は右から左へ処理されるため、
// これらの式は次のように記述したのと同じである

y = (a ** (b ** c));
x = ~(-y);
w = (x = (y = z));
q = a?b:(c?d:(e?f:g));

//////////////////////////////////////////////////////////////////////////////////////
// 4.7.6 評価順序
//////////////////////////////////////////////////////////////////////////////////////

// 演算子の優先順位と結合性により、複雑な式の中の演算子の処理順序が決められる
// しかし、優先順位と結合性は、個々の式が評価される順序までは指定しない
// JavaScriptでは常に式の評価は左から右に行われる
// 例えば、w = x + y * zという式の場合、まずwが評価され、その後、x、y、zの順序で評価が行われる
// そして、yとzの値が乗算され、xの値と加算され、wという式で指定された変数やプロパティに代入が行われる
// 式に対して、丸括弧を追加すれば、乗算や加算、代入の順序を変更できるが、評価の順（左から右）は変更はできない

// 評価の順序が問題となるのは、評価される式の中の副作用を持ち、この副作用がほかの式に影響を与える場合だけである
// もしも先ほどの例で、z式で使う変数がx式の中でインクリメントされる場合、xがzよりも前に評価されるという評価の順序が重要になる

//////////////////////////////////////////////////////////////////////////////////////
// 4.8 算術演算式
//////////////////////////////////////////////////////////////////////////////////////

// この節では、オペランドに対して算術演算など数値処理を行う演算子について解説する
// 簡単なべき乗演算子、乗算演算子、除算演算子、減算演算子からまず紹介する
// 加算演算子は、文字列の連結処理を行ったり、通常とは異なる型変換規則を使ったりするので、
// 項を分けて解説する、同じように単項演算子や、ビット演算子についても項を設けて解説する

// 算術演算子の多くは、BigInt（3.2.5章）のオペランドに対しても、通常の数値に対しても使うことができる
// ただし、BigIntと通常の数値を混ぜることはできない

// 基本的な算術演算子は、べき乗演算子（**）、乗算演算子（*）、除算演算子（/）、剰余演算子（%）、加算演算子（+）、減算演算子（-）である
// すでに述べたように、+演算子については、項を分けて解説する
// 残りの5つの演算子についてはオペランドを評価し、必要に応じて値を数値に変換し、べき乗や積、商、余り差を計算するのみ
// オペランドが数値に変換できない場合には、NaN値に変換する
// オペランドの一方がNaN（に変換される値）の場合、演算結果もNaNになる

// **演算子は（+や-よりも優先度の高い）*、/、%よりも優先度の高い演算子である
// 他の演算子とは異なり、**は右から左へ処理される
// つまり、2 ** 2 ** 3 は、2 ** 8 と同じになる
// 4 ** 3 ではない
// 一方で、-3 ** 2 という式には曖昧さが残る
// 単項マイナスとべき乗演算子の優先度によって、この式は（-3） ** 2 または -(3 ** 2)という意味になる 
// そして、プログラミング言語によって、優先度が異なる
// JavaScriptでは、どのプログラミング言語の優先度を採用するかを決める代わりに、丸括弧を使わない場合は構文エラーになるようにした
// このような式を記述する場合は必ず丸括弧を使用すること
// **は、ES2016からJavaScriptに追加された演算子である
// ただしES2016より前のバージョンでも**演算子とまったく同じ処理を行う、Math.pow()関数が利用できた

// /演算子は最初のオペランドを、2番目のオペランドで割る
// 整数と浮動小数点を区別するようなプログラミング言語に慣れ親しんでいる方だと、整数を整数で割ると、商も整数になると思うでしょう
// しかしJavaScriptの場合、すべての数値は浮動小数点なので、除算の結果も浮動小数点になる
// つまり、5 / 2の結果は2ではなく、2.5になる
// 0で除算した場合、正または負の無限大になる
// 0 / 0はNaNになる
// いずれの場合もエラーにならない

// %演算子は、最初のオペランドを2番目のオペランドで割った余りを計算する
// つまり最初のオペランドを2番目のオペランドで、商が整数になるような割り算をしたときの余りを返す
// 演算結果の符号は、最初のオペランドの符号と同じになる
// 例えば、5 % 2は1になり、-5 % 2は-1になる

// なお、余剰演算子は整数値に対して使われるのが一般的だが、浮動小数点に対しても問題なく動作する
// 例えば、6.5 % 2.1は0.2になる

//////////////////////////////////////////////////////////////////////////////////////
// 4.8.1 +演算子
//////////////////////////////////////////////////////////////////////////////////////

// 二項演算子の+演算子は、数値オペランドがあれば加算を行い、文字列オペランドの場合は結合を行います

1 + 2                       // 3
"hello" + " " + "there"     // "hello there"
"1" + "2"                   // "12"

// 両方のオペランドの値が数値の場合、または両方のオペランドの値が文字列の場合は、+演算子がどのような処理をするかは明らかである
// しかし、このほかの場合には、型変換が必要となる
// +演算子の型変換規則では、文字列の結合が優先的に行われる
// オペランドの一方が文字列、または文字列に変換できるオブジェクトの場合、もう一方のオペランドは文字列に変換され、連結処理が行われる

// 正確に言えば、+演算子は次のように振る舞う

// オペランドの値のどちらかがオブジェクトの場合、3.9.3章で解説したオブジェクトから基礎型値への変換アルゴリズムを使って、オブジェクトを基本型に変換する
// Dateオブジェクトは、toString()メソッドを使って変換を行う
// そのほかのオブジェクトは、valueOf()メソッドが基本型値を返すのであればvalueOf()メソッドを使って型変換を行う
// しかし、多くのオブジェクトは意味のあるvalueOf()メソッドを持たないので、その場合はtoString()を使って型変換を行う

// オブジェクトから基本型へ型変換の後、オペランドの一方が文字列の場合、もう一方のオペランドも文字列に変換し連結処理を行う

// それ以外の場合は、両方のオペランドを数値（またはNaN）に変換し、加算処理が行われる

1 + 2               // 3: 加算
"1" + "2"           // "12": 連結
"1" + 2             // "12": 数値から文字列へ変換の後、連結
"1" + {}            // "1[object Object]": オブジェクトから文字列の変換の後、連結
true + true         // 2: 論理値から数値へ変換の後、加算
2 + null            // 2: nullを0に変換した後、加算
2 + undefined       // NaN: undefinedをNaNに変換した後、加算

// 文字列と数値に対して、+演算子を使った場合、結合法則が成り立たない場合がある
// つまり、演算子の実行順序によって演算結果が変わってしまうということである

1 + 2 + " blind mice"       // "3 blind mice"
1 + (2 + " blind mice")     // "12 blind mice"

// 最初の行は丸括弧がなく、+演算子は左から右に処理されるので、2つの数値がまず加算される
// そして、その加算結果が文字列に連結される
// 2番目の行では、丸括弧によって演算順序が変更されている
// 数値の2が連結されて新しい文字列が生成される
// 次に、数値1も文字列として連結され、最終的な文字列が得られる

//////////////////////////////////////////////////////////////////////////////////////
// 4.8.2 単項算術演算子
//////////////////////////////////////////////////////////////////////////////////////

// 単項演算子は、1つのオペランドの値に対して処理を行い、新たな値を生成する
// JavaScriptでは単項演算子はすべて優先順位が高く、すべて右結合成を持つ
// この項で解説する単項算術演算子（+、-、++、--）はすべて、必要に応じてオペランドを数値に変換する
// なお、+と-は単項演算子としても二項演算子としても使われることに注意すること

// 単項プラス（+）
// 単項プラス演算子は、オペランドを数値（またはNaN）に変換し、変換した値を返す
// オペランドがすでに数値の場合には、この演算子は何もしない
// BigInt値に対して単項プラス演算子を使うことはできない
// BigInt値は通常の数値に変換できないためである

// 単項マイナス（-）
// -を単項演算子として使うと、必要に応じて、オペランドを数値に変換し、変換結果の符号を反転させる

// インクリメント（++）
// ++演算子は、オペランドをインクリメントする（1を加える）
// オペランドは変数や、配列の要素、オブジェクトのプロパティなど、左辺値でなければならない
// オペランドを数値に変換し、この数値に1を加算し、加算した結果を変数や要素、プロパティに代入し直す
// ++演算子の戻り値は、オペランドと位置関係で変わる
// オペランドの前で使った場合（前置インクリメント演算子）、オペランドをインクリメントし、インクリメント後の値が評価結果になる
// オペランドの後で使った場合（後置インクリメント演算子）、オペランドをインクリメントし、インクリメント前の値が評価結果になる

let i = 1, j = ++i;     // iもjも2
let n = 1, m = n++;     // nは2だが、mは1

// x++という式は、x=x+1と常に同じという訳ではない
// ++演算子は、文字列の結合処理を行わない
// ++演算子はオペランドを常に数値に変換し、インクリメントする
// xが文字列の1の場合、++xは数値の2になる
// これに対して、x+1は文字列の"11"になる

// また、JavaScriptが自動的にセミコロンを挿入するために、オペランドと後置インクリメント演算子の間には改行を入れてはならない
// もしも、改行を入れてしまうと、JavaScriptはオペランドだけで1つの完成した文字と判断し、後置演算子の前にセミコロンを挿入してしまう

// このインクリメント演算子は、前置形式のものも後置形式のものも、forループ（5.4.5章）のカウンタをインクリメントするときによく使われる

// デクリメント（--）
// --演算子は、オペランドとして左辺値を必要とする
// オペランドを数値に変換し、この数値から1を減算し、減算した結果をオペランドに代入し直す
// ++演算子と同じように、--演算子の値も、オペランドに対する位置によって変わる
// --をオペランドの前に置くと、そのオペランドの値から1を引き、1を引いた値が返される
// オペランドの後ろに--を置いた場合は、そのオペランドの値から1を引く点は同じだが、元のままの値（1を引く前の値）が返される
// オペランドの後に記述する場合は、オペランドと--演算子の間に改行を入れないようにすること

//////////////////////////////////////////////////////////////////////////////////////
// 4.8.3 ビット演算子
//////////////////////////////////////////////////////////////////////////////////////

// ビット演算子は、2新表記の数値のビットを操作するための低レベル演算子である
// ビット演算子は一般的な算術演算は行わない
// しかし、ビット演算子は数値オペランドに対して処理を行い、演算結果も数値になるため、ここではビット演算子も算術演算子に分類される
// 最初の4種類の演算子は、オペランドの各ビットを論理値（1をtrue、0をfalse）と見なし、ビット単位で論理演算を実行する
// 残りの3種類は、左や右へビットを移動する演算子である
// ビット演算子は、JavaScriptプログラミングではあまり使われることはない
// 負数の2の補数表現など、整数の2進表記にあまり馴染みのない方はこの項を飛ばしても問題ない

// ビット演算子はオペランドとして整数値が必要である
// また、この整数値は64ビットの浮動小数点表現形式ではなく、32ビット整数表現形式で表されているのもとして処理を行う
// これらの演算子は、必要であればオペランドを数値に変換し、オペランドの小数点部分を削除したり、
// 33ビット目以上のビットを捨てたりすることで、32ビットの整数表現で表せるようにする
// シフト演算子の右側オペランドには、0から31までの数値が必要である
// まず、オペランドを符号なしの32ビットの整数に変換した後、2進数表記の6ビット名城のビットを無視することで、0から31までに収まるようにする
// 意外に思うかもしれないが、NaN、Infinity、-Infinityをビット演算子のオペランドとして使うと0に変換される

// この項で紹介するビット演算子は>>>演算子を除いてすべて、通常の数値オペランドにもBigInt(3.2.5章)にも使うことが可能

// ビット積演算子（&）
// ビット積演算子（&）は、整数引数の各ビット単位で論理積を計算する
// 両方のオペランドではそれぞれ対応するビットが1のとき、結果のビットが1になる
// 例えば、0x1234 & 0x00FFの評価結果は0x0034となる

// ビット和演算子（|）
// ビット和演算子（|）は、整数引数の各ビット単位で論理和を計算する
// どちらか一方または両方のオペランドでそれぞれ対応するビットが1のときに結果のビットが1になる
// 例えば、0x1234 | 0x00FFの評価結果は0x12FFとなる

// ビット排他的論理和演算子（^）
// ビット排他的論理和演算子（^）は、整数引数の各ビット単位で排他的論理和を計算する
// 2つのオペランドのどちらか一方で対応するビットが1のときに（両方が1の場合を除く）結果のビットが1になる
// 排他的論理和はどちらか一方がtrueであるが、両方はtrueではないという意味である
// 例えば、0xFF00 ^ 0xF0F0 の評価結果は0x0FF0になる

// ビット否定演算子（~）
// ビット否定演算子（~）は単項演算子で。オペランドは整数引数が1つだけである
// ビット否定演算子は、オペランドのすべてのビットを反転させる
// JavaScriptでは、符号を変えて1を引いた値になる
// 例えば、~0x0f（15）の評価結果は0xfffffff0（−16）になる

// 左シフト演算子（<<）
// 左シフト演算子（<<）は、前のオペランドのすべてのビットを後ろのオペランドに指定された数だけ左側に移動させる
// この数は0から31までの範囲の整数になる
// 例えば、a << 1 は、aの右端のビットを右から2番目のビットに、aの右から2番目にあったビットを3番目に、という具合に順にシフトしていく
// 新しい右端のビットにはゼロが入り、元の32番目のビットは捨てられる
// このように1つずつビット位置をシフトする操作は、元の値に2を掛ける演算と同じになる
// ビット位置を2つシフトすると、4倍したことになる
// 例えば、7 << 2の評価結果は28になる

// 符号付き右シフト演算子（>>）（左端に符号ビットをコピー）
// 符号付き右シフト演算子（>>）は、前のオペランドのすべてのビットを後ろのオペランドに指定された数だけ右側に移動させる
// この数は0から31までの範囲の整数になる
// 右側からはみ出たビットは捨てられる
// 左端には、元のオペランドの符号ビットと同じ値が入る
// これは、結果の符号を元と同じ符号にするためである
// 元のオペランドが正なら、左端のビットにゼロが入る
// 元のオペランドが負なら、左端ビットに1が入る
// ビット位置を右に1つだけシフトすると、2で割って余りを捨てるのと同じ結果になる
// ビット位置を右に2つシフトすると、4で割って余りを捨てるのと同じ結果になる
// 例えば、7 >> 1と-7 >> 1の評価結果は、それぞれ3と−4になる

// 符号なし右シフト演算子（>>>）（左端ビットは常に0）
// 符号なし右シフト演算子（>>>）は、左端に入る値が前のオペランドの符号にかかわらず常に0であること以外は、>>演算子と同じである
// 符号付きの32ビット整数を符号なし整数として扱いたいときにこの演算子を使う
// 例えば、-1 >> 4と-1 >>> 4の評価結果は、それぞれ-1と0x0fffffffになる
// ビット演算子の中で、この>>>演算子だけは、BigInt値に使うことができない
// この>>>演算子は最上位ビットを1にするという方法で負数を表す32ビット整数には意味がありますが、
// このような方法で負数を表さないBigInt値に対しては意味がないからである

//////////////////////////////////////////////////////////////////////////////////////
// 4.9 関係演算子
//////////////////////////////////////////////////////////////////////////////////////

// この節では、JavaScriptの関係演算子について解説する
// 関係円盤氏は2つの値の関係（例えば、「等しい」や「より小さい」、「プロパティかどうか」）を調べて、
// その結果に基づいてtrueまたはfalseを返す
// 関係演算子を返す値は常に論理値になる
// この論理演算値はif文やwhile文やfor文（5章）でプログラムの実行を制御するときによく使われる
// この後、項を分けて、等値演算子、不等演算子、比較演算子、in演算子、instanceof演算子について解説する

//////////////////////////////////////////////////////////////////////////////////////
// 4.9.1 等値演算子と不等演算子
//////////////////////////////////////////////////////////////////////////////////////

// 等値演算子（==）と同値演算子（===）は、2つのオペランドの値が同じかどうか調べる
// 両演算子とも、オペランドには任意の型が使える
// オペランドが等しい場合はtrueを返し、異なる場合はfalseを返すところも同じである
// ただし、等値演算子と同値演算子では「同じ」の定義が異なる
// 同値演算子（===）は、厳密に2つのオペランドが「同一」であるかどうかを調べる
// 等値演算子（==）は、もっと緩やかに型変換を行いながら値を比較して、2つのオペランドが「等しい」かどうか調べる

// 不等演算子（!=）と非同値演算子（!==）は、それぞれ等値演算子（==）と同値演算子（===）の逆の動きをする
// 不等演算子（!=）は、==演算子で2つの値が等しいと判断される場合にfalseを返し、等しくない場合にtrueを返す
// 非同値演算子（!==）は、2つの値が同一の場合にfalseを返し、同一でない場合にtrueを返す
// 4.10章で解説するが、!演算子は論理否定（NOT）演算子を行う
// この演算子と関連付けて、!=を「等しくない」、!==を「同一でない」と考えて覚えるとよい

// =、==、===演算子
// JavaScriptには=、==、===演算子がある
// この代入演算子、等値演算子、同一演算子の違いをよく理解してく必要がある
// そして、コードを書くときには適切な演算子を使うようにすること
// この3つの演算子はすべて「イコール」と読みたくなるが、
// =については「代入する」、==については「等しい」、===については「同値である」と読むようにすると混乱しにくい
// ==演算子は、JavaScriptのレガシーな機能である
// 一般に、バグの温床と考えられている
// ==、!=の代わりに===、!==を使うようにすること

// 3.8章で解説したように、JavaScriptではオブジェクトを値ではなく、参照で比較する
// あるオブジェクトは、そのオブジェクト自身とは等しくなるが、ほかのオブジェクトとは等しくならない
// 2つの異なるオブジェクトが同じ名前と値のプロパティを同じ数だけ持っていたとしても、この2つのオブジェクトは等しいとは判定されない
// 同じ要素を同じ順序でもつ2つの配列も等しいと判定されない

//////////////////////////////////////////////////////////////////////////////////////
// 4.9.1.1 同値演算子
//////////////////////////////////////////////////////////////////////////////////////

// 同値演算子（===）は、オペランドを評価し、次のような規則で型変換を行わずに2つの値を比較する

// ・2つの値の型が異なる場合は、2つの値は等しくないと判定する

// ・2つの値が両方ともnullの場合、また2つの値が両方ともundefinedの場合、2つの値は等しいと判定する

// ・両方の値が論理値のtrueであるか、両方の値が論理値のfalseであれば、等しいと判断する

// ・どちらか一方、または両方ともNaNの場合、等しくないと判定する
// 　NaN値はNaN値自身を含めて、どの値とも等しくならない
// 　xがNaNかどうかを調べるときは、x !== xという式か、isNaN()グローバル関数を使うこと

// ・両方の値が数値で、同じ値を保つ場合は、等しいと判定する
// 　一方の値が0でもう一方の値が-0の場合も等しいと判定する

// ・量の方値が文字列で、同じ位置に同じ16ビット値（3.3章コラム）が含まれる場合、2つの値を等しいと判定する
// 　文字列の長さや内容が異なる場合は、等しくないと判定する
// 　同じ内容で、同じ見た目になるような2つの文字列が、異なる16ビット値でエンコードされている場合、
// 　JavaScriptはUnicodeの正規化処理を行わないので、===演算子や、==演算子ではこの2つの文字列を等しくないと判定する

// ・両方の値が同じオブジェクトや配列、関数を参照していれば、等しいと判定されない
// 　両方の値が異なるオブジェクトを参照している場合は、等しいとは判定されない
// 　両方のオブジェクトがたとえ同じプロパティを持つ場合でも、等しいとは判定されない

//////////////////////////////////////////////////////////////////////////////////////
// 4.9.1.2 型変換を伴う等値演算子
//////////////////////////////////////////////////////////////////////////////////////

// 等値演算子（===）は、同値演算子と同じような処理を行うが、少しる緩やかに比較を行う
// 2つのオペランドの型が異なる場合は、型変換を行った後に、再度比較を行う

// ・どちらも同じ型の場合は、両方の値が同一かを調べる
// 　先ほど説明した方法で値が同一かどうかを調べ、同一であれば等しいと判定する
// 　値が同一でなければ、等しくないと判定する

// ・型が異なる場合は、両方が同じ型になるように変換してから、以下の基準に基づいて、等しいかどうかを判定する

// 　ーどちらか一方の値がnullで他方がundefinedの場合、等しいと判定する

// 　ーどちらか一方の値が数値で他方が文字列の場合、文字列を数値に変換してから比較を行う

// 　ーどちらか一方の値がtrueの場合、trueを１に変換してから比較を行う
// 　　どちから一方の値がfalseの場合、falseを0に変換してから比較を行う

// 　ーどちらか一方の値がオブジェクトで他方が数値または文字列の場合、3.9.3章で紹介したアルゴリズムを使って、
// 　　オブジェクトを基本型に変換してから比較を行う
// 　　オブジェクトを基本型に変換するには、toString()メソッドまたはvalueOf()メソッドが使われる
// 　　コアJavaScriptの組み込みクラスでは、valueOf()変換がtoString()変換おり優先される
// 　　ただし、Dateクラスだけは例外で、常にtoString()変換が行われる
// 　ー上記意外の場合は、等しくないと判定する

// 型変換を伴う等値テキストの例を以下に紹介する

 "1" == true // true

// 2つの値は見た目がまったく異なっているが、この式はtrueになる
// 論理値のtrueがまず1に変換され、文字列の"1"に変換された後、比較が行われる
// 2つの値は同じ数値に変換されたので、この比較は等しい（true）ということになる

//////////////////////////////////////////////////////////////////////////////////////
// 4.9.2 比較演算子
//////////////////////////////////////////////////////////////////////////////////////

// 比較演算子は2つのオペランドの相対的な順序（数値上またはアルファベット順）を調べる
// 比較演算子には以下のようなものがある

// 小なり演算子（<）
// 小なり演算子（<）は、1番目のオペランドが2番目のオペランドより小さいときにtrueを返す
// それ以外のときにはfalseを返す

// 大なり演算子（>）
// 大なり演算子（>）は、1番目のオペランドが2番目のオペランドより大きいときにtrueを返す
// それ以外のときにはfalseを返す

// 小なりイコール演算子（<=）
// 小なりイコール演算子（<=）は、1番目のオペランドが2番目のオペランドに等しいか、あるいはそれより小さいときにtrueを返す
// それ以外のときにはfalseを返す

// 大なりイコール演算子（>=）
// 大なりイコール演算子（>=）は、1番目のオペランドが2番目のオペランドに等しいか、あるいはそれより大きいときにtrueを返す
// それ以外の時にはfalseを返す

// 比較演算子のオペランドには任意の型が指定できる
// しかし、比較は数値と文字列のどちらかの形式で行われるので、数値でも文字列でもないものは、そのどちらかに変換される
// 型変換と比較は次の規則に従う

// ・どちらかのオペランドがオブジェクトの場合、3.9.3章で最後で述べた方法で、オブジェクトは基本型に変換される
// 　つまり、valueOf()メソッドが基本型値を返す場合は、この値が使われる
// 　基本型値を返さない場合は、toString()メソッドの戻り値が使われる

// ・オブジェクトから基本型へ変換の後、両方のオペランドが文字列の場合、この2つの文字列をアルファベット順で比較する
// 　ここで「アルファベット順」とは、文字列を構成する16ビットUnicode値の数値順序になる

// ・オブジェクトから基本型へ変換の後、少なくとも片一方のオペランドが文字列ではない場合、
// 　両方のオペランドが数値に変換され、数値的に比較される
// 　0と-0は等しいと判定される
// 　Infinityは他の数値よりも大きいと判定される
// 　-Infinityは他の数値よりも小さいと判定される
// 　どちらかのオペランドがNaNの場合、またはNaNに変換される場合、比較演算子は常にfalseを返す
// 　算術演算子では通常の値とBigInt値を組み合わせることはできないが、比較演算子では通用の数値とBigInt値を比較することができる

// すでに述べたように、JavaScriptでは文字列は16ビットの整数値の並びであるため、
// 文字列比較は単純に2つの文字列の値を数値的に比較するだけである
// Unicodeで定義されている数値順序は、ある特定の言語やロケールで使われる伝統的な文字順序として一致していない場合もある
// また、文字列は大文字と小文字を区別して比較される
// Unicodeでは（少なくともASCIIの範囲では）大文字は小文字より「小さい」と判定されるので注意すること
// 例えば「Zoo」は「aardvark」よりも小さいことになる

// もっとしっかりとした文字列比較を行いたい場合は、String.localeCompare()メソッドを使用すること
// このメソッドは、ロケール固有のアルファベット順序を考慮に入れて比較を行う
// 大文字と小文字を区別しないで比較したい場合は、まず文字列をすべてString.toLowerCase()メソッドを使って小文字に変換するか、
// String.toUpperCase()メソッドを使って大文字に変換した後、比較をすること
// なお、もっと汎用的で言語を考慮した比較を行いたい場合、Intl.Collatorクラスを使用すること
// Intl.Collatorクラスについては11.7.3章で解説する

// +演算子も比較演算子も、オペランドが数値か文字列化で振る舞いが変わる
// +演算子は、文字列処理を優先する
// オペランドもいずれかが文字列の場合、連結処置が行われる
// 比較演算子は、数値を優先する
// 文字列結合を行うのは、両方のオペランドが文字列の場合のみだけである
// 例をいくつか解説する

1 + 2           // 3: 加算
"1" + "2"       // "12": 連結
"1" + 2         // "12": 2は"2"に変換される
11 < 3          // false: 数値で比較
"11" < "3"      // true: 文字列で比較
"11" < 3        // false: 数値で比較 "11"は11に変換される
"one" < 3       // false: 数値で比較 "one"はNaNに変換される

// 最後に注意するが、小なりイコール演算子（<=）や大なりイコール（>=）は、
// 2つの値が「等しい」かどうかを判定するために等値演算子や同値演算子を使わない
// 小なりイコール演算子は単に「大なり」の反対の意味で、大なりイコール演算子は「小なり」の反対の意味である
// なお、オペランドのどちらかがNaNの場合は、4つの比較演算子はすべてfalseを返す

